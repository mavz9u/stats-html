<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <base href="./">
  <title>–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</title>
  <style>
  :root {
    --bg-color:#0f172a;
    --card-bg:#1e293b;
    --card-hover:#27354d;
    --text-color:#e2e8f0;
    --text-muted:#94a3b8;
    --border-color:#334155;
    --accent:#6366f1;
    --font-main:'Inter','Segoe UI',Tahoma,sans-serif;
  }
  body{margin:0;padding:0;font-family:var(--font-main);color:var(--text-color);background:var(--bg-color);line-height:1.5}
  h1,h2,h3{font-weight:600;color:var(--text-color)}
  .container{max-width:1400px;margin:0 auto;padding:24px}
  .top-row{display:flex;flex-wrap:wrap;gap:24px;margin-bottom:32px}
  .info-block,.total-block,.pie-block{
    background:var(--card-bg);
    border:1px solid var(--border-color);
    border-radius:12px;
    padding:24px;
    flex:1;
    min-width:300px;
    box-shadow:0 4px 12px rgba(0,0,0,0.3);
  }
  .info-block{flex-basis:40%}.total-block{flex-basis:25%}.pie-block{flex-basis:35%}
  .info-block h2,.total-block h2,.pie-block h2{margin:0 0 16px;font-size:24px}
  .info-list,.total-list{list-style:none;margin:0;padding:0;font-size:16px}
  .total-list li{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .total-list .marker{width:14px;height:14px;border-radius:50%;display:inline-block;margin-right:10px;flex-shrink:0}
  .legend{margin-top:12px;font-size:14px}
  .legend-item{display:flex;align-items:center;margin-bottom:8px;color:var(--text-muted)}
  .legend-color{width:12px;height:12px;border-radius:2px;margin-right:8px;flex-shrink:0}
  .filters{margin:8px 0 24px;display:flex;flex-wrap:wrap;gap:24px;align-items:flex-end}
  .filter-group{display:flex;flex-direction:column;min-width:220px}
  .filter-group label{font-size:14px;margin-bottom:6px;color:var(--text-muted)}
  .filter-group input[type="number"],
  .filter-group input[type="datetime-local"]{
    background:var(--card-bg);border:1px solid var(--border-color);color:var(--text-color);border-radius:8px;padding:6px 8px
  }
  .filter-group input[type="checkbox"]{accent-color:var(--accent)}
  .difficulty-filter{display:flex;gap:12px;margin:10px 0;color:var(--text-muted)}
  .difficulty-filter label{display:flex;align-items:center;gap:4px;font-size:14px}
  .difficulty-filter input{accent-color:var(--accent)}
  #pieContainer{height:280px;border:1px solid var(--border-color);border-radius:12px;padding:16px;background:var(--card-bg)}
  .chart-container{height:400px;margin-bottom:40px;border:1px solid var(--border-color);border-radius:12px;padding:16px;background:var(--card-bg);box-shadow:0 4px 12px rgba(0,0,0,0.3)}
  .chart-container canvas,#pieContainer canvas{width:100% !important;height:auto !important;display:block}
  .chart-container{ padding-bottom: 90px; }
  .chart-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  .chart-controls{display:flex;gap:8px}
  
  .chart-controls button,
  .export-buttons button{
    padding:6px 12px;font-size:14px;border:1px solid var(--border-color);border-radius:6px;background:var(--card-bg);color:var(--text-color);cursor:pointer;transition:background .2s,color .2s
  }
  .chart-controls button:hover,
  .export-buttons button:hover{background:var(--card-hover);color:#fff}
  .export-buttons{margin:12px 0 20px}
  .warn{padding:12px;border:1px solid #f0c36d;background:#3f3010;border-radius:8px;margin-bottom:16px;display:none}
</style>
</head>
<body>
  <div class="container">

    <h1 style="margin-bottom:8px">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è</h1>
    <p style="margin:0 0 24px;color:var(--text-muted)">–î–∞–Ω–Ω—ã–µ –∞–≥—Ä–µ–≥–∏—Ä—É—é—Ç—Å—è –∑–∞ —Å—É—Ç–∫–∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ UTC.</p>

    <div id="warn" class="warn">
      –ù–µ –Ω–∞–π–¥–µ–Ω –æ–¥–∏–Ω –∏–∑ –ª–æ–∫–∞–ª—å–Ω—ã—Ö —Å–∫—Ä–∏–ø—Ç–æ–≤:
      <code>chart.umd.min.js</code>,
      <code>hammer.min.js</code>,
      <code>chartjs-plugin-zoom.min.js</code>.
      –ü–æ–ª–æ–∂–∏—Ç–µ —Ñ–∞–π–ª—ã –≤ —Ç—É –∂–µ –ø–∞–ø–∫—É –∏ –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.
    </div>

    <div id="file-load-container" style="display:none;margin-bottom:14px;padding:10px;border:1px solid var(--border-color);border-radius:8px;background:var(--card-bg)">
      <p style="margin:0 0 8px;font-size:16px;color:var(--text-color)">–í—ã–±–µ—Ä–∏—Ç–µ JSON-—Ñ–∞–π–ª –ø—Ä–æ—Ñ–∏–ª—è (UserProfiles/&lt;id&gt;.json)</p>
      <button id="select-file" style="border:1px solid var(--border-color);background:var(--card-bg);color:var(--text-color);border-radius:6px;padding:6px 12px">–í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª</button>
      <input type="file" id="file-input" accept=".json" style="display:none">
    </div>

    <div class="top-row">
      <div class="info-block">
        <h2>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ</h2>
        <ul class="info-list" id="user-info-list"></ul>
      </div>

      <div class="total-block">
        <h2>–û–±—â–µ–µ –≤—Ä–µ–º—è –∏–≥—Ä</h2>
        <ul class="total-list" id="total-list"></ul>
      </div>

      <div class="pie-block">
        <h2>–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ<br>–≤—Ä–µ–º–µ–Ω–∏</h2>
        <div id="pieContainer"><canvas id="pieChart"></canvas></div>
        <div class="legend" id="pie-legend"></div>
      </div>
    </div>

    <div class="filters">
      <div class="filter-group" style="flex:1;min-width:260px">
        <label>–î–∏–∞–ø–∞–∑–æ–Ω —Å–µ—Å—Å–∏–π (–ø–æ –∏–Ω–¥–µ–∫—Å–∞–º)</label>
        <input id="range-start" type="number" min="1" step="1" value="1" style="width:110px">
        <input id="range-end"   type="number" min="1" step="1" value="1" style="width:110px;margin-top:6px">
        <div id="range-values" style="font-size:14px;margin-top:6px;color:var(--text-muted)"></div>
      </div>
      <div class="filter-group" style="flex:1;min-width:280px">
        <label>–î–∏–∞–ø–∞–∑–æ–Ω –¥–∞—Ç</label>
        <div style="display:flex;gap:6px;align-items:center">
          <input type="datetime-local" id="start-date" style="flex:1">
          <span>‚Äî</span>
          <input type="datetime-local" id="end-date" style="flex:1">
        </div>
      </div>
      <div class="filter-group" style="min-width:220px">
        <label>–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ü–∏–∏</label>
        <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
          <input type="checkbox" id="toggle-ttf">
          <label for="toggle-ttf" style="font-size:14px;color:var(--text-muted)">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤—Ä–µ–º—è –¥–æ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–±–æ—Ä–∞</label>
        </div>
      </div>
    </div>

    <div class="export-buttons"><button id="export-csv">–í—ã–≥—Ä—É–∑–∏—Ç—å –≤ CSV</button></div>

   <div class="chart-container" id="chart-container-game">
 <div class="chart-header">
   <h3>–¶–≤–µ—Ç–æ—á–Ω—ã–π —Å–∞–¥</h3>
   <div class="chart-controls">
     <button data-reset-id="gameChart">–°–±—Ä–æ—Å–∏—Ç—å –∑—É–º</button>
     <button data-download-id="gameChart">PNG</button>
   </div>
 </div>

 <div class="difficulty-filter" data-chart="game">
   <label><input type="radio" name="gameDiff" value="all" checked> –í—Å–µ</label>
   <label><input type="radio" name="gameDiff" value="easy"> –õ–µ–≥–∫–∏–π</label>
   <label><input type="radio" name="gameDiff" value="hard"> –°–ª–æ–∂–Ω—ã–π</label>
 </div>

 <canvas id="gameChart"></canvas>
</div>

    <div class="chart-container" id="chart-container-fish">
      <div class="chart-header">
        <h3>–ê–∫–≤–∞—Ä–∏—É–º</h3>
        <div class="chart-controls">
          <button data-reset-id="fishChart">–°–±—Ä–æ—Å–∏—Ç—å –∑—É–º</button>
          <button data-download-id="fishChart">PNG</button>
        </div>
      </div>
      <div class="difficulty-filter" data-chart="fish">
        <label><input type="radio" name="fishDiff" value="all" checked> –í—Å–µ</label>
        <label><input type="radio" name="fishDiff" value="easy"> –õ–µ–≥–∫–∏–π</label>
        <label><input type="radio" name="fishDiff" value="hard"> –°–ª–æ–∂–Ω—ã–π</label>
      </div>
      <canvas id="fishChart"></canvas>
    </div>

    <div class="chart-container" id="chart-container-butterfly">
      <div class="chart-header">
        <h3>–ë–∞–±–æ—á–∫–∏</h3>
        <div class="chart-controls">
          <button data-reset-id="butterflyChart">–°–±—Ä–æ—Å–∏—Ç—å –∑—É–º</button>
          <button data-download-id="butterflyChart">PNG</button>
        </div>
      </div>
      <div class="difficulty-filter" data-chart="butterfly">
        <label><input type="radio" name="butterflyDiff" value="all" checked> –í—Å–µ</label>
        <label><input type="radio" name="butterflyDiff" value="easy"> –õ–µ–≥–∫–∏–π</label>
        <label><input type="radio" name="butterflyDiff" value="hard"> –°–ª–æ–∂–Ω—ã–π</label>
      </div>
      <canvas id="butterflyChart"></canvas>
    </div>

       <div class="chart-container" id="chart-container-snowflakes">
     <div class="chart-header">
       <h3>–°–Ω–µ–∂–∏–Ω–∫–∏</h3>
       <div class="chart-controls">
         <button data-reset-id="snowflakesChart">–°–±—Ä–æ—Å–∏—Ç—å –∑—É–º</button>
         <button data-download-id="snowflakesChart">PNG</button>
       </div>
     </div>

     <div class="difficulty-filter" data-chart="snowflakes">
       <label><input type="radio" name="snowflakesDiff" value="all" checked> –í—Å–µ</label>
       <label><input type="radio" name="snowflakesDiff" value="easy"> –õ–µ–≥–∫–∏–π</label>
       <label><input type="radio" name="snowflakesDiff" value="hard"> –°–ª–æ–∂–Ω—ã–π</label>
     </div>

     <canvas id="snowflakesChart"></canvas>
   </div>


    <div class="chart-container" id="chart-container-memory">
      <div class="chart-header">
        <h3>–ö–∞—Ä—Ç–æ—á–∫–∏</h3>
        <div class="chart-controls">
          <button data-reset-id="memoryChart">–°–±—Ä–æ—Å–∏—Ç—å –∑—É–º</button>
          <button data-download-id="memoryChart">PNG</button>
        </div>
      </div>
      <div class="difficulty-filter" data-chart="memory">
        <label><input type="radio" name="memoryDiff" value="all" checked> –í—Å–µ</label>
        <label><input type="radio" name="memoryDiff" value="4"> 4 –∫–∞—Ä—Ç–æ—á–∫–∏</label>
        <label><input type="radio" name="memoryDiff" value="12"> 12 –∫–∞—Ä—Ç–æ—á–µ–∫</label>
      </div>
      <canvas id="memoryChart"></canvas>
    </div>

    <div class="chart-container" id="chart-container-fruit">
      <div class="chart-header">
        <h3>–§—Ä—É–∫—Ç–æ–≤–∞—è –±–∏—Ç–≤–∞</h3>
        <div class="chart-controls">
          <button data-reset-id="fruitChart">–°–±—Ä–æ—Å–∏—Ç—å –∑—É–º</button>
          <button data-download-id="fruitChart">PNG</button>
        </div>
      </div>
      <canvas id="fruitChart"></canvas>
    </div>
  </div>

  <script src="chart.umd.min.js"></script>
  <script src="hammer.min.js"></script>
  <script src="chartjs-plugin-zoom.min.js"></script>

  <script>
    const css=getComputedStyle(document.documentElement);
    const TEXT_COLOR=css.getPropertyValue('--text-color').trim();
    const BORDER_COLOR=css.getPropertyValue('--border-color').trim();
    Chart.defaults.color=TEXT_COLOR;
    Chart.defaults.borderColor=BORDER_COLOR;
    Chart.defaults.font.family=css.getPropertyValue('--font-main').trim();
    Chart.defaults.layout = Chart.defaults.layout || {};
    Chart.defaults.layout.padding = { bottom: 20 };

    const pieLabelPlugin = {
      id: 'pieLabelPlugin',
      afterDatasetsDraw(chart) {
        const {ctx, data} = chart;
        const ds = data?.datasets?.[0];
        if (!ds) return;
        const total = (ds.data||[]).reduce((a,b)=>a+Number(b||0),0);
        if(!total) return;
        ctx.save();
        ctx.font='bold 14px Arial';
        ctx.fillStyle=TEXT_COLOR;
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        const meta = chart.getDatasetMeta(0);
        meta.data.forEach((arc,i)=>{
          const v = Number(ds.data[i]||0);
          if(!v) return;
          const p = v/total;
          if(p<0.03) return;
          const label = Math.round(p*100)+'%';
          const r = (arc.outerRadius+arc.innerRadius)/2;
          const ang=(arc.startAngle+arc.endAngle)/2;
          ctx.fillText(label, arc.x+Math.cos(ang)*(r+8), arc.y+Math.sin(ang)*(r+8));
        });
        ctx.restore();
      }
    };
  </script>

  <script>
  (() => {
    let __uwpLibTries = 0;

    const NAME = {
      GameScene: '–¶–≤–µ—Ç–æ—á–Ω—ã–π —Å–∞–¥',
      Fish: '–ê–∫–≤–∞—Ä–∏—É–º',
      ButterflyGameScene: '–ë–∞–±–æ—á–∫–∏',
      Snowflakes: '–°–Ω–µ–∂–∏–Ω–∫–∏',
      MemoryMatchScene: '–ö–∞—Ä—Ç–æ—á–∫–∏',
      FrutGame: '–§—Ä—É–∫—Ç–æ–≤–∞—è –±–∏—Ç–≤–∞'
    };

    /* üé® –ü–ê–õ–ò–¢–†–´ –ò–ì–† */
    const COLOR = {
      // –¶–≤–µ—Ç–æ—á–Ω—ã–π —Å–∞–¥ ‚Äî –ø–∞—Å—Ç–µ–ª—å
      GameScene: '#85C3CE',        // –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å/–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ
      GameSceneAlt: '#F78770',     // –æ—à–∏–±–∫–∏ (hard)

      // –ê–∫–≤–∞—Ä–∏—É–º ‚Äî –º–æ—Ä—Å–∫–∞—è –ø–∞–ª–∏—Ç—Ä–∞
      Fish: '#0B184B',             // –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ
      FishAlt: '#0296A7',          // –æ—à–∏–±–∫–∏
      FishMissed: '#5FCAD8',       // –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ

      // –ë–∞–±–æ—á–∫–∏ ‚Äî –∑–µ–ª—ë–Ω–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–µ
      ButterflyGameScene: '#CCABDB', // –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ (easy)
      ButterflyCaught: '#089770',    // –ø–æ–π–º–∞–Ω–æ (hard)
      ButterflyErr: '#E53935',       // –æ—à–∏–±–∫–∏ (hard)

      // –°–Ω–µ–∂–∏–Ω–∫–∏ ‚Äî —Ö–æ–ª–æ–¥–Ω—ã–µ
      Snowflakes: '#54CDCC',         // –ø–æ–π–º–∞–Ω–æ (easy)
      SnowflakesAlt: '#215522',      // –ø–æ–π–º–∞–Ω–æ (hard)
      SnowflakesMissed: '#DCD964',   // –ø—Ä–æ–ø—É—â–µ–Ω–æ (hard)

      // –ö–∞—Ä—Ç–æ—á–∫–∏ ‚Äî –æ—Ä–∞–Ω–∂–µ–≤–æ-–±–µ–∂–µ–≤—ã–µ
      MemoryMatchScene: '#FFA726',   // –ø–∞—Ä—ã
      MemoryErr: '#E53935',          // –æ—à–∏–±–∫–∏

      // –§—Ä—É–∫—Ç—ã ‚Äî —Ç—ë–ø–ª—ã–µ
      FrutGame: '#E26B65',           // –æ—á–∫–∏ (easy)
      FrutSliced: '#26A69A',         // —Ä–∞–∑—Ä–µ–∑–∞–Ω–æ (hard)
      FrutMissed: '#FFA726',         // –ø—Ä–æ–ø—É—â–µ–Ω–æ (hard)
      FrutErr: '#E53935',            // –æ—à–∏–±–∫–∏ (hard)

      // –≥–ª–æ–±–∞–ª—å–Ω—ã–µ
      ERR: '#E53935',
      TTF: '#FFD700'                 // –≤—Å–µ–≥–¥–∞ –∂—ë–ª—Ç—ã–π
    };

    const CANON = ['GameScene','Fish','ButterflyGameScene','Snowflakes','MemoryMatchScene','FrutGame'];
    const ALIAS = {
      'FishGameScene':'Fish','Aquarium':'Fish',
      'HardButterflyGameScene':'ButterflyGameScene',
      'SnowflakesScene':'Snowflakes',
      'Memory':'MemoryMatchScene','MemoryGame':'MemoryMatchScene',
      'FruitGame':'FrutGame','FruitGameScene':'FrutGame'
    };
    const canonId = id => ALIAS[id] || id;

    let profileData = null;
    const allSessions = {
      GameScene: [],
      Fish: [],
      ButterflyGameScene: [],
      Snowflakes: [],
      MemoryMatchScene: [],
      FrutGame: []
    };
    let filter = { indexRange:[1,1], dateRange:[null,null] };
    const charts = {};

    function okLibs(){
      if(!window.Chart) return false;
      try {
        const zp = window['chartjs-plugin-zoom'] || window.ChartZoom;
        if (zp) Chart.register(zp);
      } catch(e){}
      return true;
    }

    function getQueryParams(){
      const q={};
      location.search.substring(1).split('&').forEach(p=>{
        const[k,v]=p.split('=');
        if(k) q[decodeURIComponent(k)]=decodeURIComponent(v||'');
      });
      return q;
    }

    function formatDuration(sec){
      const h=Math.floor(sec/3600);
      const m=Math.floor((sec%3600)/60);
      const s=Math.floor(sec%60);
      return h>0?`${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`:`${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    const showWarn = f=>document.getElementById('warn').style.display=f?'block':'none';

    function showFileLoader(){
      const box=document.getElementById('file-load-container');
      const btn=document.getElementById('select-file');
      const input=document.getElementById('file-input');
      box.style.display='block';
      btn.onclick=()=>input.click();
      input.onchange=async e=>{
        const f=e.target.files[0];
        if(!f) return;
        try{
          profileData=JSON.parse(await f.text());
          box.style.display='none';
          initUI();
        }catch(err){
          console.error('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞',err);
        }
      };
    }

    async function start(){
      if (!okLibs()) {
        showWarn(true);
        showFileLoader();
        return;
      }
      showWarn(false);

      if (window.PROFILE_DATA) {
        profileData = window.PROFILE_DATA;
        initUI();
        return;
      }
      
      const {profilePath}=getQueryParams();
      if(profilePath){
        try{
          const r=await fetch(profilePath);
          if(!r.ok) throw new Error('HTTP '+r.status);
          profileData=await r.json();
          initUI();
          return;
        }catch(err){
          console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å —á–µ—Ä–µ–∑ fetch:', err);
        }
      }
      
      showFileLoader();
    }

    function initUI(){
      const lst=document.getElementById('user-info-list');
      lst.innerHTML='';
      const name=profileData.userName||profileData.displayName||profileData.username||profileData.name||'?';
      const c=profileData.creationDate?new Date(profileData.creationDate):null;
      const l=profileData.lastPlayedDate?new Date(profileData.lastPlayedDate):null;
      const fmt=d=>!d?'‚Äî':`${String(d.getDate()).padStart(2,'0')}.${String(d.getMonth()+1).padStart(2,'0')}.${String(d.getFullYear()).slice(-2)} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
      
      [{label:'–ò–º—è',value:name},{label:'–î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏',value:fmt(c)},{label:'–ü–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å',value:fmt(l)}]
        .forEach(it=>{
          const li=document.createElement('li');
          li.textContent=`${it.label}: ${it.value}`;
          lst.appendChild(li);
        });

      Object.keys(allSessions).forEach(g => allSessions[g] = []);
      (profileData.statsByGame || []).forEach(g => {
        const gidCanon = canonId(g.gameId);
        if (!allSessions[gidCanon]) return;
        const arr = (g.sessionHistory || []).slice().sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
        arr.forEach(s => {
          const difficultyRaw = (g.gameId === 'HardButterflyGameScene') ? 'hard' : (s.difficulty ?? '');
          const difficulty = String(difficultyRaw).toLowerCase();
          const ttf = Number(s.timeToFirstCorrectAction ?? 0);

          let caught = Number(s.caught ?? 0);
          let errors = Number(s.errors ?? 0);
          if (difficulty === 'hard') {
            if (caught === 0 && (s.correctActions ?? 0) > 0)   caught = Number(s.correctActions);
            if (errors === 0 && (s.incorrectActions ?? 0) > 0) errors = Number(s.incorrectActions);
          }

          allSessions[gidCanon].push({
            dt: new Date(s.startTime),
            duration: Number(s.durationInSeconds || 0),
            correct: Number(s.correctActions || 0),
            incorrect: Number(s.incorrectActions || 0),
            ttf,
            difficulty,
            missed: Number(s.missed || 0),
            caught,
            errors,
            correctPairs: Number(s.correctPairs || 0),
            score: Number(s.score || 0)
          });

        });
      });

      const maxCount=Math.max(...Object.values(allSessions).map(a=>a.length),1);
      filter.indexRange=[1,maxCount];
      let minD=null,maxD=null;
      Object.values(allSessions).forEach(a=>a.forEach(s=>{
        if(!minD||s.dt<minD)minD=s.dt;
        if(!maxD||s.dt>maxD)maxD=s.dt;
      }));
      filter.dateRange=[minD,maxD];

      const rs=document.getElementById('range-start');
      const re=document.getElementById('range-end');
      rs.min=1; re.min=1; rs.max=maxCount; re.max=maxCount; re.value=maxCount;
      const rv=document.getElementById('range-values');
      const upd=()=>{
        rv.textContent=`–í—ã–±—Ä–∞–Ω–æ ${rs.value}-${re.value} –∏–∑ ${maxCount}`;
        filter.indexRange=[+rs.value,+re.value];
        applyFiltersAndRender();
      };
      rs.onchange=upd; re.onchange=upd; upd();

      const sI=document.getElementById('start-date');
      const eI=document.getElementById('end-date');
      const toVal=d=>!d?'':`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}T${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      sI.value=toVal(minD); eI.value=toVal(maxD);
      sI.onchange=()=>{
        const d=new Date(sI.value);
        if(!isNaN(d)) {
          filter.dateRange[0]=d;
          applyFiltersAndRender();
        }
      };
      eI.onchange=()=>{
        const d=new Date(eI.value);
        if(!isNaN(d)) {
          filter.dateRange[1]=d;
          applyFiltersAndRender();
        }
      };
      document.getElementById('toggle-ttf').onchange=()=>applyFiltersAndRender();

      document.getElementById('export-csv').onclick=exportCSV;
      
      document.querySelectorAll('.difficulty-filter input').forEach(r => {
        r.onchange = () => applyFiltersAndRender();
      });
      document.querySelectorAll('.chart-controls button').forEach(b=>{
        if(b.dataset.resetId){
          b.onclick=()=>{
            const ch=charts[b.dataset.resetId];
            if(ch&&ch.resetZoom) ch.resetZoom();
          };
        }
        if(b.dataset.downloadId){
          b.addEventListener('click',()=>{
            const ch=charts[b.dataset.downloadId];
            if(!ch) return;
            const a=document.createElement('a');
            a.href=ch.toBase64Image();
            a.download=`${b.dataset.downloadId}-${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
            a.click();
          });
        }
      });

      applyFiltersAndRender();
    }

    function getFilteredSessions() {
      const res = {};
      const [iS, iE] = filter.indexRange.map(v => Math.round(v));
      const [dS, dE] = filter.dateRange;

      Object.keys(allSessions).forEach(g => {
        if (g === 'ButterflyGameScene' || g === 'HardButterflyGameScene') return;
        const arr = allSessions[g] || [];
        res[g] = arr.filter((s, idx) => {
          const i = idx + 1;
          const okI = i >= iS && i <= iE;
          const okD = (!dS || s.dt >= dS) && (!dE || s.dt <= dE);
          return okI && okD;
        });
      });

      const easy = allSessions.ButterflyGameScene || [];
      const hard = allSessions.HardButterflyGameScene || [];
      if (easy.length || hard.length) {
        const ts = s => (s.dt instanceof Date && !isNaN(s.dt))
          ? s.dt.getTime()
          : Date.parse(s.startTime || s.dt || 0) || 0;

        let merged = [...easy, ...hard];
        merged = merged.filter(s => (!dS || s.dt >= dS) && (!dE || s.dt <= dE));
        merged.sort((a, b) => ts(a) - ts(b));
        merged = merged.filter((_, idx) => {
          const i = idx + 1;
          return i >= iS && i <= iE;
        });

        res.ButterflyGameScene = merged;
      }

      return res;
    }

    function computeTotals(f) {
      const t = { GameScene:0, Fish:0, ButterflyGameScene:0, Snowflakes:0, MemoryMatchScene:0, FrutGame:0 };
      CANON.forEach(g => (f[g]||[]).forEach(s => t[g] += s.duration));
      return t;
    }

    function renderSummary(totals){
      const list=document.getElementById('total-list');
      list.innerHTML='';
      const entries=Object.entries(totals).filter(([,v])=>v>0).sort((a,b)=>b[1]-a[1]);
      entries.forEach(([gid,time])=>{
        const li=document.createElement('li');
        const left=document.createElement('span');
        const m=document.createElement('span');
        m.className='marker';
        m.style.background=COLOR[gid];
        left.appendChild(m);
        const lb=document.createElement('span');
        lb.textContent=NAME[gid];
        left.appendChild(lb);
        li.appendChild(left);
        const right=document.createElement('span');
        right.textContent=formatDuration(time);
        li.appendChild(right);
        list.appendChild(li);
      });

      const data=entries.map(([gid,v])=>v);
      const labels=entries.map(([gid])=>NAME[gid]);
      const colors=entries.map(([gid])=>COLOR[gid]);
      const sum=data.reduce((a,v)=>a+v,0);
      if(charts.pieChart) charts.pieChart.destroy();
      charts.pieChart=new Chart(document.getElementById('pieChart').getContext('2d'),{
        type:'doughnut',
        data:{labels,datasets:[{data,backgroundColor:colors,borderWidth:0}]},
        options:{
          responsive:true,
          maintainAspectRatio:false,
          plugins:{
            legend:{display:false},
            tooltip:{
              callbacks:{
                label:c=>`${c.label}: ${formatDuration(c.parsed)} (${sum? (c.parsed/sum*100).toFixed(1):0}%)`
              }
            }
          },
          cutout:'60%'
        },
        plugins:[pieLabelPlugin]
      });

      const lg=document.getElementById('pie-legend');
      lg.innerHTML='';
      entries.forEach(([gid])=>{
        const d=document.createElement('div');
        d.className='legend-item';
        const box=document.createElement('span');
        box.className='legend-color';
        box.style.background=COLOR[gid];
        const tx=document.createElement('span');
        tx.textContent=NAME[gid];
        d.appendChild(box);
        d.appendChild(tx);
        lg.appendChild(d);
      });
    }

    function legendRect(){
      return {
        labels: {
          usePointStyle: false,
          color: TEXT_COLOR,
          generateLabels(chart) {
            const ds = chart.data.datasets || [];
            return ds.map((d,i)=>({
              text: d.label,
              fillStyle: d.borderColor || d.backgroundColor,
              strokeStyle: d.borderColor || d.backgroundColor,
              hidden: !chart.isDatasetVisible(i),
              datasetIndex: i
            }));
          }
        }
      };
    }

    const zoomOpts = {
      zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'x'},
      pan:{enabled:true,mode:'x'}
    };

    function axis(yMax){
      const step=Math.max(1,Math.ceil(yMax/4));
      let max=step*4;
      if(yMax>max) max=step*5;
      return {step,max};
    }

    function oneLineLabel(dt){
      const Y=dt.getFullYear();
      const M=String(dt.getMonth()+1).padStart(2,'0');
      const D=String(dt.getDate()).padStart(2,'0');
      const h=String(dt.getHours()).padStart(2,'0');
      const m=String(dt.getMinutes()).padStart(2,'0');
      const s=String(dt.getSeconds()).padStart(2,'0');
      return `${Y}-${M}-${D} ${h}:${m}:${s}`;
    }

    function renderCharts(f){
      const ttfChecked =
        (document.getElementById('toggle-ttf')?.checked ?? false) ||
        (document.getElementById('chkTTF')?.checked ?? false);

  /* ---------- –¶–≤–µ—Ç–æ—á–Ω—ã–π —Å–∞–¥ ---------- */
  (()=>{
    const gid='GameScene';
    let d=f[gid];
    const c=document.getElementById('gameChart');
    if(charts.gameChart) charts.gameChart.destroy();

    const diffEl = document.querySelector('input[name="gameDiff"]:checked');
    const diff = diffEl ? diffEl.value : 'all';
    if (d) { if (diff !== 'all') d = d.filter(s => s.difficulty === diff); }

    if(!d || !d.length){
      c.getContext('2d').clearRect(0,0,c.width,c.height);
      document.getElementById('chart-container-game').style.display='none';
      return;
    }
    document.getElementById('chart-container-game').style.display='block';

    const labels = d.map(s=>oneLineLabel(s.dt));
    const showTTF = ttfChecked && d.some(s => (s.ttf ?? 0) > 0);

    const datasets = [];
    const yAxes = {};
    const cat = 0.80;
    const bar = 1.00;

    const yMaxTime = Math.max(1, ...d.map(s => s.duration || 0), ...(showTTF ? d.map(s => s.ttf || 0) : [1]));
    const timeAxis = axis(yMaxTime);
    yAxes.yTime = {
      type:'linear', position:'right', beginAtZero:true,
      suggestedMax: timeAxis.max,
      ticks:{ stepSize: timeAxis.step, color: TEXT_COLOR },
      grid:{ drawOnChartArea:false }, border:{ color: BORDER_COLOR }
    };

    datasets.push({
      type:'line',
      label:'–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, —Å',
      data:d.map(s=>s.duration),
      borderColor:COLOR.GameScene,
      backgroundColor:COLOR.GameScene,
      pointRadius:3, tension:0.2,
      yAxisID:'yTime', order:1
    });

    if (showTTF) {
      datasets.push({
        type:'line',
        label:'–í—Ä–µ–º—è –¥–æ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–±–æ—Ä–∞, —Å',
        data:d.map(s=>s.ttf||null),
        borderColor:COLOR.TTF, backgroundColor:COLOR.TTF,
        borderDash:[6,4], pointRadius:3, tension:0.2,
        yAxisID:'yTime', order:0
      });
    }

    const dataCorrect = d.map(s => Number(s.correct || s.correctActions || 0));
    const dataErrorsHard = d.map(s => s.difficulty === 'hard' ? (s.incorrect || s.incorrectActions || s.errors || 0) : null);

    if (dataCorrect.some(v => v>0) || dataErrorsHard.some(v => v!=null && v>0)) {
      const yMaxCounts = Math.max(
        1,
        ...dataCorrect,
        ...dataErrorsHard.filter(v=>v!=null).map(v=>Number(v)||0)
      );
      const countAxis = axis(yMaxCounts);
      yAxes.yCounts = {
        type:'linear', position:'left', beginAtZero:true,
        suggestedMax: countAxis.max,
        ticks:{ stepSize: countAxis.step, color: TEXT_COLOR },
        grid:{ color: BORDER_COLOR }, border:{ color: BORDER_COLOR }
      };

      datasets.push({
        label:'–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ',
        data:dataCorrect,
        backgroundColor:COLOR.GameScene,
        yAxisID:'yCounts', order:2,
        barPercentage:bar, categoryPercentage:cat
      });

      if (dataErrorsHard.some(v => v != null && Number(v) > 0)) {
        datasets.push({
          label:'–û—à–∏–±–∫–∏ (—Å–ª–æ–∂–Ω—ã–π)',
          data: dataErrorsHard,
          backgroundColor: COLOR.GameSceneAlt,
          yAxisID:'yCounts', order:2,
          barPercentage: bar, categoryPercentage: cat
        });
      }
    }

    charts.gameChart=new Chart(c.getContext('2d'),{
      type:'bar',
      data:{labels,datasets},
      options:{
        responsive:true, maintainAspectRatio:false,
        scales:{
          x:{ type:'category', ticks:{ autoSkip:false, maxRotation:45, minRotation:45, color:TEXT_COLOR,
                callback:function(v){ return this.getLabelForValue(v); } },
              grid:{ color:BORDER_COLOR }, border:{ color:BORDER_COLOR }},
          ...yAxes
        },
        plugins:{
          legend:{ position:'top', ...legendRect() },
          tooltip:{ callbacks:{
            title:c=>{ const i=c[0].dataIndex; const dt=d[i].dt;
                       return `#${i+1} ‚Äî ${dt.toISOString().replace('T',' ').slice(0,19)}`; },
            label:c=> c.dataset.yAxisID==='yTime'
              ? `${c.dataset.label}: ${Number(c.parsed.y).toFixed(2)}`
              : `${c.dataset.label}: ${c.parsed.y}`
          }},
          zoom: zoomOpts
        }
      }
    });
  })();


  /* ---------- –ê–∫–≤–∞—Ä–∏—É–º ---------- */
  (()=>{
    const gid='Fish';
    let d=f[gid];
    const c=document.getElementById('fishChart');
    if(charts.fishChart) charts.fishChart.destroy();
    
    const diff = document.querySelector('input[name="fishDiff"]:checked').value;
    if (d && diff !== 'all') d = d.filter(s => s.difficulty === diff);

    if(!d||!d.length){
      c.getContext('2d').clearRect(0,0,c.width,c.height);
      document.getElementById('chart-container-fish').style.display = 'none';
      return;
    }
    document.getElementById('chart-container-fish').style.display = 'block';

    const labels=d.map(s=>oneLineLabel(s.dt));
    const showTTF = ttfChecked && d.some(s => (s.ttf ?? 0) > 0);

    const yMaxCounts=Math.max(1,...d.map(s=>Math.max(s.correct,s.incorrect, s.missed || 0)));
    const stepCounts=Math.max(1,Math.ceil(yMaxCounts/4));
    const suggestedMaxCounts=Math.max(yMaxCounts,stepCounts*4);

    const yMaxTime=showTTF?Math.max(...d.map(s=>s.ttf||0),1):1;
    const stepTime=Math.max(1,Math.ceil(yMaxTime/4));
    const suggestedMaxTime=Math.max(yMaxTime,stepTime*4);

    const cat=0.80;
    const bar=1.00;

    const datasets=[
      {
        label:'–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ',
        data:d.map(s=>s.correct),
        backgroundColor:COLOR.Fish,
        borderColor:COLOR.Fish,
        borderWidth:0,
        yAxisID:'yCounts',
        order:2,
        barPercentage:bar,
        categoryPercentage:cat
      },
      {
        label:'–û—à–∏–±–∫–∏',
        data:d.map(s=>s.incorrect),
        backgroundColor:COLOR.FishAlt,
        borderColor:COLOR.FishAlt,
        borderWidth:0,
        yAxisID:'yCounts',
        order:2,
        barPercentage:bar,
        categoryPercentage:cat
      }
    ];

    if (d.some(s => s.missed > 0)) {
      datasets.push({
        label: '–ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ',
        data: d.map(s => s.missed),
        backgroundColor: COLOR.FishMissed,
        yAxisID: 'yCounts',
        order: 2,
        barPercentage: bar,
        categoryPercentage: cat
      });
    }

    if(showTTF){
      datasets.push({
        type:'line',
        label:'–í—Ä–µ–º—è –¥–æ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–±–æ—Ä–∞, —Å',
        data:d.map(s=>s.ttf||null),
        borderColor:COLOR.TTF,
        backgroundColor:COLOR.TTF,
        pointRadius:3,
        tension:0.2,
        yAxisID:'yTime',
        order:1
      });
    }

    charts.fishChart=new Chart(c.getContext('2d'),{
      type:'bar',
      data:{labels,datasets},
      options:{
        responsive:true,
        maintainAspectRatio:false,
        scales:{
          x:{ type:'category', ticks:{ autoSkip:false, maxRotation:45, minRotation:45, color:TEXT_COLOR,
                callback:function(v){ return this.getLabelForValue(v); } },
              grid:{color:BORDER_COLOR}, border:{color:BORDER_COLOR}},
          yCounts:{ type:'linear', position:'left', beginAtZero:true,
            suggestedMax:suggestedMaxCounts, ticks:{stepSize:stepCounts,color:TEXT_COLOR},
            grid:{color:BORDER_COLOR}, border:{color:BORDER_COLOR}},
          yTime:{ type:'linear', position:'right', display:showTTF, beginAtZero:true,
            suggestedMax:suggestedMaxTime, ticks:{stepSize:stepTime,color:TEXT_COLOR},
            grid:{drawOnChartArea:false}, border:{color:BORDER_COLOR}}
        },
        plugins:{legend:{position:'top',...legendRect()},
          tooltip:{callbacks:{title:c=>{const i=c[0].dataIndex; const dt=d[i].dt; return `#${i+1} ‚Äî ${dt.toISOString().replace('T',' ').slice(0,19)}`},
                               label:c=> c.dataset.yAxisID==='yTime'
                                 ? `${c.dataset.label}: ${c.parsed.y.toFixed(2)}`
                                 : `${c.dataset.label}: ${c.parsed.y}`}},
          zoom: zoomOpts
        }
      }
    });
  })();

  /* ---------- –ë–∞–±–æ—á–∫–∏ ---------- */
  (()=>{
    const gid='ButterflyGameScene';
    let d=f[gid];
    const c=document.getElementById('butterflyChart');
    if(charts.butterflyChart) charts.butterflyChart.destroy();

    const diff = document.querySelector('input[name="butterflyDiff"]:checked').value;
    if (d && diff !== 'all') d = d.filter(s => s.difficulty === diff);

    if(!d||!d.length){
      c.getContext('2d').clearRect(0,0,c.width,c.height);
      document.getElementById('chart-container-butterfly').style.display = 'none';
      return;
    }
    document.getElementById('chart-container-butterfly').style.display = 'block';

    const ts = s => (s.dt instanceof Date && !isNaN(s.dt)) ? s.dt.getTime()
             : Date.parse(s.startTime || s.dt || 0) || 0;
    d = d.slice().sort((a,b)=> ts(a) - ts(b));
    const labels = d.map(s => oneLineLabel(s.dt instanceof Date ? s.dt : new Date(s.startTime)));

    const ttfChk =
      (document.getElementById('toggle-ttf') && document.getElementById('toggle-ttf').checked) ||
      (document.getElementById('chkTTF') && document.getElementById('chkTTF').checked);
    const showTTF = ttfChk && d.some(s => (s.ttf ?? 0) > 0);

    const datasets = [];
    const yAxes = {};
    const bar = 1.0, cat = 0.8;

    const yMaxTime = Math.max(1, ...d.map(s => s.duration), ...(showTTF ? d.map(s => s.ttf || 0) : []));
    const timeAxis = axis(yMaxTime);
    yAxes.yTime = {
      type: 'linear', position: 'right', beginAtZero: true,
      suggestedMax: timeAxis.max, ticks: { stepSize: timeAxis.step, color: TEXT_COLOR },
      grid: { drawOnChartArea: false }, border: { color: BORDER_COLOR }
    };

    datasets.push({
      type: 'line',
      label: '–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, —Å',
      data: d.map(s => s.duration),
      borderColor: COLOR.ButterflyGameScene,
      backgroundColor: COLOR.ButterflyGameScene,
      pointRadius: 3, tension: 0.2,
      yAxisID: 'yTime', order: 1
    });

    if (showTTF) {
      datasets.push({
        type: 'line',
        label: '–í—Ä–µ–º—è –¥–æ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–±–æ—Ä–∞, —Å',
        data: d.map(s => s.ttf || null),
        borderColor: COLOR.TTF, backgroundColor: COLOR.TTF,
        borderDash: [6,4], pointRadius: 3, tension: 0.2,
        yAxisID: 'yTime', order: 0
      });
    }

    const easyData = d.filter(s => s.difficulty === 'easy');
    const hardData = d.filter(s => s.difficulty === 'hard');

    let yMaxCounts = 1;
    if (easyData.length) yMaxCounts = Math.max(yMaxCounts, ...easyData.map(s => s.correct||0));
    if (hardData.length) yMaxCounts = Math.max(
      yMaxCounts,
      ...hardData.map(s => s.caught||0),
      ...hardData.map(s => s.errors||0)
    );

    const countAxis = axis(yMaxCounts);
    yAxes.yCounts = {
      type: 'linear', position: 'left', beginAtZero: true,
      suggestedMax: countAxis.max,
      ticks: { stepSize: countAxis.step, color: TEXT_COLOR },
      grid: { color: BORDER_COLOR }, border: { color: BORDER_COLOR }
    };

    if (diff === 'easy' || diff === 'all') {
      const arr = d.map(s => s.difficulty === 'easy' ? (s.correct||0) : null);
      if (arr.some(v=>v)) {
        datasets.push({
          label: '–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ (–ª—ë–≥–∫–∏–π)',
          data: arr,
          backgroundColor: COLOR.ButterflyGameScene,
          yAxisID: 'yCounts', order: 2,
          barPercentage: bar, categoryPercentage: cat
        });
      }
    }

    if (diff === 'hard' || diff === 'all') {
      const arrCaught = d.map(s => s.difficulty === 'hard' ? (s.caught||0) : null);
      if (arrCaught.some(v=>v)) {
        datasets.push({
          label: '–ü–æ–π–º–∞–Ω–æ (—Å–ª–æ–∂–Ω—ã–π)',
          data: arrCaught,
          backgroundColor: COLOR.ButterflyCaught,
          yAxisID: 'yCounts', order: 2,
          barPercentage: bar, categoryPercentage: cat
        });
      }
      const arrErr = d.map(s => s.difficulty === 'hard' ? (s.errors||0) : null);
      if (arrErr.some(v=>v)) {
        datasets.push({
          label: '–û—à–∏–±–∫–∏ (—Å–ª–æ–∂–Ω—ã–π)',
          data: arrErr,
          backgroundColor: COLOR.ButterflyErr,
          yAxisID: 'yCounts', order: 2,
          barPercentage: bar, categoryPercentage: cat
        });
      }
    }

    charts.butterflyChart=new Chart(c.getContext('2d'), {
      type: 'bar',
      data: { labels, datasets },
      options: {
        responsive: true, maintainAspectRatio: false,
        scales: {
          x: { type: 'category',
               ticks: { autoSkip: false, maxRotation: 45, minRotation: 45, color: TEXT_COLOR },
               grid: { color: BORDER_COLOR }, border: { color: BORDER_COLOR } },
          ...yAxes
        },
        plugins: {
          legend: { position: 'top', ...legendRect() },
          tooltip: { callbacks: { title: c => { const i = c[0].dataIndex; const dt = d[i].dt; return `#${i + 1} ‚Äî ${dt.toISOString().replace('T', ' ').slice(0, 19)}` } } },
          zoom: zoomOpts
        }
      }
    });
  })();

  /* ---------- –°–Ω–µ–∂–∏–Ω–∫–∏ ---------- */
  (() => {
    const gid='Snowflakes';
    let d=f[gid];
    const c=document.getElementById('snowflakesChart');
    if(charts.snowflakesChart) charts.snowflakesChart.destroy();

    const diffEl = document.querySelector('input[name="snowflakesDiff"]:checked');
    const diff = diffEl ? diffEl.value : 'all';
    if (d && diff !== 'all') d = d.filter(s => s.difficulty === diff);

    if (!d || !d.length) {
      c.getContext('2d').clearRect(0,0,c.width,c.height);
      document.getElementById('chart-container-snowflakes').style.display = 'none';
      return;
    }
    document.getElementById('chart-container-snowflakes').style.display = 'block';

    const toNum = v => (v==null ? 0 : (typeof v === 'number' ? v : Number(v)||0));

    const getCaught = s => {
      const c  = toNum(s.caught);
      const ok = toNum(s.correct);
      return c > 0 ? c : ok;
    };
    const getMissed = s => {
      const m   = toNum(s.missed);
      const inc = toNum(s.incorrect);
      const er  = toNum(s.errors);
      return m > 0 ? m : (inc > 0 ? inc : er);
    };

    const labels = d.map(s => oneLineLabel(s.dt));

    const ttfChk =
      (document.getElementById('toggle-ttf')?.checked ?? false) ||
      (document.getElementById('chkTTF')?.checked ?? false);
    const showTTF = ttfChk && d.some(s => toNum(s.ttf) > 0);

    const datasets = [];
    const yAxes = {};
    const bar = 1.0, cat = 0.8;

    const yMaxTime = Math.max(1, ...d.map(s => toNum(s.duration)), ...(showTTF ? d.map(s => toNum(s.ttf)) : []));
    const timeAxis = axis(yMaxTime);
    yAxes.yTime = {
      type:'linear', position:'right', beginAtZero:true,
      suggestedMax: timeAxis.max,
      ticks:{ stepSize: timeAxis.step, color: TEXT_COLOR },
      grid:{ drawOnChartArea:false }, border:{ color: BORDER_COLOR }
    };

    datasets.push({
      type:'line',
      label:'–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, —Å',
      data:d.map(s=>toNum(s.duration)),
      borderColor:COLOR.Snowflakes,
      backgroundColor:COLOR.Snowflakes,
      pointRadius:3, tension:0.2,
      yAxisID:'yTime', order:1
    });

    if (showTTF) {
      datasets.push({
        type:'line',
        label:'–í—Ä–µ–º—è –¥–æ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–±–æ—Ä–∞, —Å',
        data:d.map(s => s.ttf==null ? null : toNum(s.ttf)),
        borderColor:COLOR.TTF, backgroundColor:COLOR.TTF,
        borderDash:[6,4], pointRadius:3, tension:0.2,
        yAxisID:'yTime', order:0
      });
    }

    if (diff === 'easy' || diff === 'all') {
      const dataCaughtEasy = d.map(s => s.difficulty === 'easy' ? getCaught(s) : null);
      const yMaxCountsEasy = Math.max(1, ...dataCaughtEasy.filter(v=>v!=null).map(v=>toNum(v)));
      const countAxisEasy = axis(yMaxCountsEasy);
      yAxes.yCounts = {
        type:'linear', position:'left', beginAtZero:true,
        suggestedMax: countAxisEasy.max,
        ticks:{ stepSize: countAxisEasy.step, color: TEXT_COLOR },
        grid:{ color: BORDER_COLOR }, border:{ color: BORDER_COLOR }
      };

      datasets.push({
        label:'–ü–æ–π–º–∞–Ω–æ (–ª—ë–≥–∫–∏–π)',
        data:dataCaughtEasy,
        backgroundColor: COLOR.Snowflakes,
        yAxisID:'yCounts', order:2,
        barPercentage:bar, categoryPercentage:cat
      });
    }

    const hardMask = d.map(s => (s.difficulty === 'hard'));
    const anyHard  = hardMask.some(Boolean);

    if (diff === 'hard' || (diff === 'all' && anyHard)) {
      const caught = d.map((s,i) => hardMask[i] ? getCaught(s)  : null);
      const missed = d.map((s,i) => hardMask[i] ? getMissed(s) : null);

      if (!yAxes.yCounts) {
        const yMaxCounts = Math.max(
          1,
          ...caught.filter(v=>v!=null).map(v=>toNum(v)),
          ...missed.filter(v=>v!=null).map(v=>toNum(v))
        );
        const countAxis = axis(yMaxCounts);
        yAxes.yCounts = {
          type:'linear', position:'left', beginAtZero:true,
          suggestedMax: countAxis.max,
          ticks:{ stepSize: countAxis.step, color: TEXT_COLOR },
          grid:{ color: BORDER_COLOR }, border:{ color: BORDER_COLOR }
        };
      }

      datasets.push({
        label:'–ü–æ–π–º–∞–Ω–æ (—Å–ª–æ–∂–Ω—ã–π)',
        data: caught,
        backgroundColor: COLOR.SnowflakesAlt,
        yAxisID:'yCounts', order:2,
        barPercentage:bar, categoryPercentage:cat
      });
      datasets.push({
        label:'–ü—Ä–æ–ø—É—â–µ–Ω–æ (—Å–ª–æ–∂–Ω—ã–π)',
        data: missed,
        backgroundColor: COLOR.SnowflakesMissed,
        yAxisID:'yCounts', order:2,
        barPercentage:bar, categoryPercentage:cat
      });
    }

    charts.snowflakesChart = new Chart(c.getContext('2d'), {
      type:'bar',
      data:{ labels, datasets },
      options:{
        responsive:true, maintainAspectRatio:false,
        scales:{
          x:{ type:'category', ticks:{ autoSkip:false, maxRotation:45, minRotation:45, color:TEXT_COLOR }, grid:{ color:BORDER_COLOR }, border:{ color:BORDER_COLOR } },
          ...yAxes
        },
        plugins:{
          legend:{ position:'top', ...legendRect() },
          tooltip:{
            callbacks:{
              title:c=>{ const i=c[0].dataIndex; const dt=d[i].dt; return `#${i+1} ‚Äî ${dt.toISOString().replace('T',' ').slice(0,19)}`; },
              label:c=> c.dataset.yAxisID==='yTime'
                ? `${c.dataset.label}: ${Number(c.parsed.y).toFixed(2)}`
                : `${c.dataset.label}: ${c.parsed.y}`
            }
          },
          zoom: zoomOpts
        }
      }
    });
  })();

  /* ---------- –ö–∞—Ä—Ç–æ—á–∫–∏ ---------- */
  (()=>{
    const gid='MemoryMatchScene';
    let d=f[gid];
    const c=document.getElementById('memoryChart');
    if(charts.memoryChart) charts.memoryChart.destroy();

    const diff = document.querySelector('input[name="memoryDiff"]:checked').value;
    if(d && diff !== 'all') d = d.filter(s => String(s.difficulty) === String(diff));
    
    if(!d||!d.length){
      c.getContext('2d').clearRect(0,0,c.width,c.height);
      document.getElementById('chart-container-memory').style.display = 'none';
      return;
    }
    document.getElementById('chart-container-memory').style.display = 'block';
    const cat=0.80;
    const bar=1.00;
    const labels=d.map(s=>oneLineLabel(s.dt));
    const showTTF = ttfChecked && d.some(s => (s.ttf ?? 0) > 0);

    const datasets = [];
    const yAxes = {};

    const yMaxTime = Math.max(1, ...d.map(s => s.duration), ...(showTTF ? d.map(s => s.ttf || 0) : []));
    const timeAxis = axis(yMaxTime);
    yAxes.yTime = {
        type: 'linear',
        position: 'right',
        beginAtZero: true,
        suggestedMax: timeAxis.max,
        ticks: { stepSize: timeAxis.step, color: TEXT_COLOR },
        grid: { drawOnChartArea: false },
        border: { color: BORDER_COLOR }
    };
    datasets.push({
        type: 'line',
        label: '–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, —Å',
        data: d.map(s => s.duration),
        borderColor: COLOR.MemoryMatchScene,
        backgroundColor: COLOR.MemoryMatchScene,
        pointRadius: 3,
        tension: 0.2,
        yAxisID: 'yTime',
        order: 1
    });
    if (showTTF) {
        datasets.push({
            type: 'line',
            label: '–í—Ä–µ–º—è –¥–æ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–±–æ—Ä–∞, —Å',
            data: d.map(s => s.ttf || null),
            borderColor: COLOR.TTF,
            backgroundColor: COLOR.TTF,
            pointRadius: 3,
            tension: 0.2,
            yAxisID: 'yTime',
            order: 0
        });
    }

    const yMaxCounts = Math.max(1, ...d.map(s => Math.max(s.correctPairs || 0, s.errors || 0)));
    const countAxis = axis(yMaxCounts);
    yAxes.yCounts = {
        type: 'linear',
        position: 'left',
        beginAtZero: true,
        suggestedMax: countAxis.max,
        ticks: { stepSize: countAxis.step, color: TEXT_COLOR },
        grid: { color: BORDER_COLOR },
        border: { color: BORDER_COLOR }
    };
    datasets.push({
        label: '–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–∞—Ä—ã',
        data: d.map(s => s.correctPairs),
        backgroundColor: COLOR.MemoryMatchScene,
        yAxisID: 'yCounts',
        order: 2,
        barPercentage: bar,
        categoryPercentage: cat
    });
    datasets.push({
        label: '–û—à–∏–±–∫–∏',
        data: d.map(s => s.errors),
        backgroundColor: COLOR.MemoryErr,
        yAxisID: 'yCounts',
        order: 2,
        barPercentage: bar,
        categoryPercentage: cat
    });

    charts.memoryChart=new Chart(c.getContext('2d'), {
        type: 'bar',
        data: { labels, datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { type: 'category',
                     ticks: { autoSkip: false, maxRotation: 45, minRotation: 45, color: TEXT_COLOR },
                     grid: { color: BORDER_COLOR }, border: { color: BORDER_COLOR } },
                ...yAxes
            },
            plugins: {
                legend: { position: 'top', ...legendRect() },
                tooltip: { callbacks: { title: c => { const i = c[0].dataIndex; const dt = d[i].dt; return `#${i + 1} ‚Äî ${dt.toISOString().replace('T', ' ').slice(0, 19)}` } } },
                zoom: zoomOpts
            }
        }
    });
  })();

  /* ---------- –§—Ä—É–∫—Ç–æ–≤–∞—è –±–∏—Ç–≤–∞ ---------- */
  (()=> {
    const gid = 'FrutGame';
    let d = f[gid];
    const c = document.getElementById('fruitChart');
    if (charts.fruitChart) charts.fruitChart.destroy();

    if (!d || !d.length) {
      c.getContext('2d').clearRect(0,0,c.width,c.height);
      document.getElementById('chart-container-fruit').style.display = 'none';
      return;
    }
    document.getElementById('chart-container-fruit').style.display = 'block';

    const labels = d.map(s => oneLineLabel(s.dt));

    const ttfChk =
      (document.getElementById('toggle-ttf')?.checked ?? false) ||
      (document.getElementById('chkTTF')?.checked ?? false);
    const showTTF = ttfChk && d.some(s => (s.ttf ?? 0) > 0);

    const datasets = [];
    const yAxes = {};
    const cat = 0.80;
    const bar = 1.00;

    const yMaxTime = Math.max(1, ...(showTTF ? d.map(s => s.ttf || 0) : [1]));
    const timeAxis = axis(yMaxTime);
    yAxes.yTime = {
      type: 'linear', position: 'right', beginAtZero: true,
      display: showTTF,
      suggestedMax: timeAxis.max,
      ticks: { stepSize: timeAxis.step, color: TEXT_COLOR },
      grid: { drawOnChartArea: false }, border: { color: BORDER_COLOR }
    };

    if (showTTF) {
      datasets.push({
        type: 'line',
        label: '–í—Ä–µ–º—è –¥–æ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–±–æ—Ä–∞, —Å',
        data: d.map(s => s.ttf || null),
        borderColor: COLOR.TTF, backgroundColor: COLOR.TTF,
        pointRadius: 3, tension: 0.2,
        yAxisID: 'yTime', order: 0
      });
    }

    const isEasy = d.map(s => String(s.difficulty) === 'easy');
    const isHard = d.map(s => String(s.difficulty) === 'hard');

    const by = arr => arr.filter(v => v != null).map(v => Number(v) || 0);
    const yMaxCounts = Math.max(
      1,
      ...by(d.map((s,i) => isEasy[i] ? (s.score || 0) : null)),
      ...by(d.map((s,i) => isHard[i] ? (s.score || 0) : null)),
      ...by(d.map((s,i) => isHard[i] ? (s.missed || 0) : null)),
      ...by(d.map((s,i) => isHard[i] ? (s.errors || s.incorrect || 0) : null))
    );
    const countAxis = axis(yMaxCounts);
    yAxes.yCounts = {
      type: 'linear', position: 'left', beginAtZero: true,
      suggestedMax: countAxis.max,
      ticks: { stepSize: countAxis.step, color: TEXT_COLOR },
      grid: { color: BORDER_COLOR }, border: { color: BORDER_COLOR }
    };

    const dataScoreEasy = d.map((s,i) => isEasy[i] ? (s.score || 0) : null);
    datasets.push({
      label: '–û—á–∫–∏ (–ª—ë–≥.)',
      data: dataScoreEasy,
      backgroundColor: COLOR.FrutGame,
      yAxisID: 'yCounts',
      order: 2,
      barPercentage: bar,
      categoryPercentage: cat
    });

    const dataSlicedHard = d.map((s,i) => isHard[i] ? (s.score || 0) : null);
    const dataMissedHard = d.map((s,i) => isHard[i] ? (s.missed || 0) : null);
    const dataErrorsHard = d.map((s,i) => isHard[i] ? (s.errors || s.incorrect || 0) : null);

    datasets.push({
      label: '–†–∞–∑—Ä–µ–∑–∞–Ω–æ (—Å–ª–æ–∂–Ω.)',
      data: dataSlicedHard,
      backgroundColor: COLOR.FrutSliced,
      yAxisID: 'yCounts',
      order: 2,
      barPercentage: bar,
      categoryPercentage: cat
    });
    datasets.push({
      label: '–ü—Ä–æ–ø—É—â–µ–Ω–æ (—Å–ª–æ–∂–Ω.)',
      data: dataMissedHard,
      backgroundColor: COLOR.FrutMissed,
      yAxisID: 'yCounts',
      order: 2,
      barPercentage: bar,
      categoryPercentage: cat
    });
    datasets.push({
      label: '–û—à–∏–±–∫–∏ (—Å–ª–æ–∂–Ω.)',
      data: dataErrorsHard,
      backgroundColor: COLOR.FrutErr,
      yAxisID: 'yCounts',
      order: 2,
      barPercentage: bar,
      categoryPercentage: cat
    });

    charts.fruitChart = new Chart(c.getContext('2d'), {
      type: 'bar',
      data: { labels, datasets },
      options: {
        responsive: true, maintainAspectRatio: false,
        scales: {
          x: { type: 'category',
               ticks: { autoSkip: false, maxRotation: 45, minRotation: 45, color: TEXT_COLOR },
               grid: { color: BORDER_COLOR }, border: { color: BORDER_COLOR } },
          ...yAxes
        },
        plugins: {
          legend: { position: 'top', ...legendRect() },
          tooltip: { callbacks: { title: c => {
            const i = c[0].dataIndex;
            const dt = d[i].dt;
            return `#${i+1} ‚Äî ${dt.toISOString().replace('T',' ').slice(0,19)}`;
          }}},
          zoom: zoomOpts
        }
      }
    });
  })();

    }

    function applyFiltersAndRender(){
      const f = getFilteredSessions();
      const totals = computeTotals(f);
      renderSummary(totals);
      renderCharts(f);
    }

    function exportCSV(){
      const f = getFilteredSessions();
      let csv = '–ò–≥—Ä–∞,–£—Ä–æ–≤–µ–Ω—å,–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è,–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (—Å–µ–∫),–í—Ä–µ–º—è –¥–æ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–±–æ—Ä–∞ (—Å–µ–∫),–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ,–û—à–∏–±–∫–∏,–ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ,–ü–æ–π–º–∞–Ω–Ω—ã–µ,–ü–∞—Ä—ã,–û—á–∫–∏\n';
      
      const gids = Object.keys(f);

      gids.forEach(gid => {
        const sessions = f[gid] || [];
        sessions.forEach(s => {
          const dateStr = s.dt.toISOString().replace('T', ' ').slice(0, 19);
          const row = [
            NAME[gid],
            s.difficulty || '',
            dateStr,
            s.duration || 0,
            s.ttf || 0,
            s.correct || '',
            s.errors || s.incorrect || '',
            s.missed || '',
            s.caught || '',
            s.correctPairs || '',
            s.score || ''
          ];
          csv += row.join(',') + '\n';
        });
      });
      
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `game-statistics-${new Date().toISOString().slice(0,10)}.csv`;
      link.click();
    }

    fetch('data.json')
      .then(r => r.json())
      .then(data => { window.PROFILE_DATA = data; start(); })
      .catch(() => { start(); });
  })();
  </script>
</body>
</html>
