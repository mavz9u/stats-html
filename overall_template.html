<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
 <base href="./">
  <title>Общая статистика</title>
  <style>
    body{margin:0;padding:0;font-family:Arial, sans-serif;color:#000;background:#fff}
    .container{max-width:1400px;margin:0 auto;padding:20px 40px}
    .top-row{display:flex;flex-wrap:wrap;gap:20px;margin-bottom:24px}
    .info-block,.total-block,.pie-block{
      background:#fff;border:1px solid #ddd;box-shadow:0 0 5px rgba(0,0,0,.05);
      padding:20px;flex:1;min-width:280px
    }
    .info-block{flex-basis:40%}.total-block{flex-basis:25%}.pie-block{flex-basis:35%}
    .info-block h2,.total-block h2,.pie-block h2{margin:0 0 10px 0;font-size:25px}
    .info-list,.total-list{list-style:none;margin:0;padding:0;font-size:18px}
    .total-list li{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    .total-list .marker{width:14px;height:14px;border-radius:50%;display:inline-block;margin-right:10px;flex-shrink:0}
    .legend{margin-top:10px;font-size:16px}
    .legend-item{display:flex;align-items:center;margin-bottom:6px}
    .legend-color{width:12px;height:12px;border-radius:2px;margin-right:8px;flex-shrink:0}
    .filters{margin:6px 0 16px;display:flex;flex-wrap:wrap;gap:20px;align-items:center}
    .filter-group{display:flex;flex-direction:column;min-width:220px}
    .filter-group label{font-size:14px;margin-bottom:4px}
    #pieContainer{height:280px;border:1px solid #eee;padding:10px}
    .chart-container{height:500px;margin-bottom:40px;border:1px solid #eee;padding:12px}
    .chart-container canvas,#pieContainer canvas{width:100% !important;height:auto !important;display:block}

    .chart-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
    .chart-header h3{margin:0;font-size:22px}
    .chart-controls{display:flex;gap:8px}
    .chart-controls button,.export-buttons button{
      padding:4px 10px;font-size:14px;border:1px solid #bbb;border-radius:4px;background:#f5f5f5;cursor:pointer
    }
    .chart-controls button:hover,.export-buttons button:hover{background:#e0e0e0}
    .export-buttons{margin:8px 0 16px}
    .warn{padding:10px;border:1px solid #f0c36d;background:#fff7e6;border-radius:4px;margin-bottom:12px;display:none}
  </style>
</head>
<body>
  <div class="container">

    <div id="warn" class="warn">
      Не найден один из локальных скриптов:
      <code>lib/chart.umd.min.js</code>,
      <code>lib/hammer.min.js</code>,
      <code>lib/chartjs-plugin-zoom.min.js</code>.
      Положите файлы в <code>Reports/lib/</code> и обновите страницу.
    </div>

    <div id="file-load-container" style="display:none;margin-bottom:14px;padding:10px;border:1px solid #ddd;border-radius:4px;background:#fafafa">
      <p style="margin:0 0 8px;font-size:16px">Выберите JSON-файл профиля (UserProfiles/&lt;id&gt;.json)</p>
      <button id="select-file">Выбрать файл</button>
      <input type="file" id="file-input" accept=".json" style="display:none">
    </div>

    <div class="top-row">
      <div class="info-block">
        <h2>Информация о пользователе</h2>
        <ul class="info-list" id="user-info-list"></ul>
      </div>

      <div class="total-block">
        <h2>Общее время игр</h2>
        <ul class="total-list" id="total-list"></ul>
      </div>

      <div class="pie-block">
        <h2>Распределение игрового<br>времени</h2>
        <div id="pieContainer"><canvas id="pieChart"></canvas></div>
        <div class="legend" id="pie-legend"></div>
      </div>
    </div>

    <div class="filters">
      <div class="filter-group" style="flex:1;min-width:260px">
        <label>Диапазон сессий (по индексам)</label>
        <input id="range-start" type="number" min="1" step="1" value="1" style="width:110px">
        <input id="range-end"   type="number" min="1" step="1" value="1" style="width:110px;margin-top:6px">
        <div id="range-values" style="font-size:14px;margin-top:6px"></div>
      </div>
      <div class="filter-group" style="flex:1;min-width:280px">
        <label>Диапазон дат</label>
        <div style="display:flex;gap:6px;align-items:center">
          <input type="datetime-local" id="start-date" style="flex:1">
          <span>—</span>
          <input type="datetime-local" id="end-date" style="flex:1">
        </div>
      </div>
      <div class="filter-group" style="min-width:220px">
        <label>Дополнительные опции</label>
        <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
          <input type="checkbox" id="toggle-ttf">
          <label for="toggle-ttf" style="font-size:14px">Показывать время до первого выбора</label>
        </div>
      </div>
    </div>

    <div class="export-buttons"><button id="export-csv">Скачать CSV</button></div>

    <div class="chart-container" id="chart-container-game">
      <div class="chart-header">
        <h3>Цветочный сад</h3>
        <div class="chart-controls">
          <button data-reset-id="gameChart">Сбросить зум</button>
          <button data-download-id="gameChart">PNG</button>
        </div>
      </div>
      <canvas id="gameChart"></canvas>
    </div>

    <div class="chart-container" id="chart-container-fish">
      <div class="chart-header">
        <h3>Аквариум</h3>
        <div class="chart-controls">
          <button data-reset-id="fishChart">Сбросить зум</button>
          <button data-download-id="fishChart">PNG</button>
        </div>
      </div>
      <div class="difficulty-filter" data-chart="fish">
        <label><input type="radio" name="fishDiff" value="all" checked> Все</label>
        <label><input type="radio" name="fishDiff" value="easy"> Легкий</label>
        <label><input type="radio" name="fishDiff" value="hard"> Сложный</label>
      </div>
      <canvas id="fishChart"></canvas>
    </div>

    <div class="chart-container" id="chart-container-butterfly">
      <div class="chart-header">
        <h3>Бабочки</h3>
        <div class="chart-controls">
          <button data-reset-id="butterflyChart">Сбросить зум</button>
          <button data-download-id="butterflyChart">PNG</button>
        </div>
      </div>
      <div class="difficulty-filter" data-chart="butterfly">
        <label><input type="radio" name="butterflyDiff" value="all" checked> Все</label>
        <label><input type="radio" name="butterflyDiff" value="easy"> Легкий</label>
        <label><input type="radio" name="butterflyDiff" value="hard"> Сложный</label>
      </div>
      <canvas id="butterflyChart"></canvas>
    </div>

    <div class="chart-container" id="chart-container-snowflakes">
      <div class="chart-header">
        <h3>Снежинки</h3>
        <div class="chart-controls">
          <button data-reset-id="snowflakesChart">Сбросить зум</button>
          <button data-download-id="snowflakesChart">PNG</button>
        </div>
      </div>
      <canvas id="snowflakesChart"></canvas>
    </div>

    <div class="chart-container" id="chart-container-memory">
      <div class="chart-header">
        <h3>Карточки</h3>
        <div class="chart-controls">
          <button data-reset-id="memoryChart">Сбросить зум</button>
          <button data-download-id="memoryChart">PNG</button>
        </div>
      </div>
      <div class="difficulty-filter" data-chart="memory">
        <label><input type="radio" name="memoryDiff" value="all" checked> Все</label>
        <label><input type="radio" name="memoryDiff" value="4"> 4 карточки</label>
        <label><input type="radio" name="memoryDiff" value="12"> 12 карточек</label>
      </div>
      <canvas id="memoryChart"></canvas>
    </div>

    <div class="chart-container" id="chart-container-fruit">
      <div class="chart-header">
        <h3>Фруктовая битва</h3>
        <div class="chart-controls">
          <button data-reset-id="fruitChart">Сбросить зум</button>
          <button data-download-id="fruitChart">PNG</button>
        </div>
      </div>
      <canvas id="fruitChart"></canvas>
    </div>
  </div>

  <script src="lib/chart.umd.min.js"></script>
  <script src="lib/hammer.min.js"></script>
  <script src="lib/chartjs-plugin-zoom.min.js"></script>
<!-- Удален блок загрузки старых библиотек для UWP, так как WebView2 поддерживает современные версии -->

  <script>
    const pieLabelPlugin = {
      id: 'pieLabelPlugin',
      afterDatasetsDraw(chart) {
        const {ctx, data} = chart;
        const ds = data?.datasets?.[0];
        if (!ds) return;
        const total = (ds.data||[]).reduce((a,b)=>a+Number(b||0),0);
        if(!total) return;
        ctx.save();
        ctx.font='bold 14px Arial';
        ctx.fillStyle='#000';
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        const meta = chart.getDatasetMeta(0);
        meta.data.forEach((arc,i)=>{
          const v = Number(ds.data[i]||0);
          if(!v) return;
          const p = v/total;
          if(p<0.03) return;
          const label = Math.round(p*100)+'%';
          const r = (arc.outerRadius+arc.innerRadius)/2;
          const ang=(arc.startAngle+arc.endAngle)/2;
          ctx.fillText(label, arc.x+Math.cos(ang)*(r+8), arc.y+Math.sin(ang)*(r+8));
        });
        ctx.restore();
      }
    };
  </script>

  <script>
  (() => {
    let __uwpLibTries = 0;

    const NAME = {
      GameScene: 'Цветочный сад',
      Fish: 'Аквариум',
      ButterflyGameScene: 'Бабочки',
      //HardButterflyGameScene: 'Бабочки (сложн.)',
      Snowflakes: 'Снежинки',
      MemoryMatchScene: 'Карточки',
      FrutGame: 'Фруктовая битва'
    };
    const COLOR = {
      GameScene: '#4CAF50',
      Fish: '#1E88E5',
      ButterflyGameScene: '#E91E63',
      //HardButterflyGameScene: '#9C27B0',
      Snowflakes: '#00BCD4',
      MemoryMatchScene: '#FF9800',
      FrutGame: '#F44336',
      ERR: '#E53935',
      TTF: '#FFD700'
    };
    const CANON = ['GameScene','Fish','ButterflyGameScene','Snowflakes','MemoryMatchScene','FrutGame'];
    const ALIAS = {
      // рыбы
      'FishGameScene':'Fish','Aquarium':'Fish',
      // бабочки
      'HardButterflyGameScene':'ButterflyGameScene',
      // снежинки
      'SnowflakesScene':'Snowflakes',
      // карточки
      'Memory':'MemoryMatchScene','MemoryGame':'MemoryMatchScene',
      // фрукты
      'FruitGame':'FrutGame','FruitGameScene':'FrutGame'
    };
    const canonId = id => ALIAS[id] || id;

    let profileData = null;
    const allSessions = {
      GameScene: [],
      Fish: [],
      ButterflyGameScene: [],
      //HardButterflyGameScene: [],
      Snowflakes: [],
      MemoryMatchScene: [],
      FrutGame: []
    };
    let filter = { indexRange:[1,1], dateRange:[null,null] };
    const charts = {};

    function okLibs(){
      if(!window.Chart) return false;
      try {
        const zp = window['chartjs-plugin-zoom'] || window.ChartZoom;
        if (zp) Chart.register(zp);
      } catch(e){}
      return true;
    }

    function getQueryParams(){
      const q={};
      location.search.substring(1).split('&').forEach(p=>{
        const[k,v]=p.split('=');
        if(k) q[decodeURIComponent(k)]=decodeURIComponent(v||'');
      });
      return q;
    }

    function formatDuration(sec){
      const h=Math.floor(sec/3600);
      const m=Math.floor((sec%3600)/60);
      const s=Math.floor(sec%60);
      return h>0?`${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`:`${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    const showWarn = f=>document.getElementById('warn').style.display=f?'block':'none';

    function showFileLoader(){
      const box=document.getElementById('file-load-container');
      const btn=document.getElementById('select-file');
      const input=document.getElementById('file-input');
      box.style.display='block';
      btn.onclick=()=>input.click();
      input.onchange=async e=>{
        const f=e.target.files[0];
        if(!f) return;
        try{
          profileData=JSON.parse(await f.text());
          box.style.display='none';
          initUI();
        }catch(err){
          console.error('Ошибка чтения файла',err);
        }
      };
    }

    async function start(){
  if (!okLibs()) {
    // Удалено ожидание загрузки старых библиотек для UWP
    showWarn(true);
    showFileLoader();
    return;
  }
  showWarn(false);
  // далее — как у тебя (PROFILE_DATA / fetch / file picker)

      
      if (window.PROFILE_DATA) {
        console.log('Используем встроенные данные профиля');
        profileData = window.PROFILE_DATA;
        initUI();
        return;
      }
      
      const {profilePath}=getQueryParams();
      if(profilePath){
        try{
          console.log('Попытка загрузить профиль через fetch:', profilePath);
          const r=await fetch(profilePath);
          if(!r.ok) throw new Error('HTTP '+r.status);
          profileData=await r.json();
          console.log('Профиль загружен через fetch');
          initUI();
          return;
        }catch(err){
          console.warn('Не удалось загрузить профиль через fetch:', err);
        }
      }
      
      console.log('Показываем загрузчик файлов');
      showFileLoader();
    }

    function initUI(){
      const lst=document.getElementById('user-info-list');
      lst.innerHTML='';
      const name=profileData.userName||profileData.displayName||profileData.username||profileData.name||'?';
      const c=profileData.creationDate?new Date(profileData.creationDate):null;
      const l=profileData.lastPlayedDate?new Date(profileData.lastPlayedDate):null;
      const fmt=d=>!d?'—':`${String(d.getDate()).padStart(2,'0')}.${String(d.getMonth()+1).padStart(2,'0')}.${String(d.getFullYear()).slice(-2)} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
      
      [{label:'Имя',value:name},{label:'Дата регистрации',value:fmt(c)},{label:'Последняя активность',value:fmt(l)}]
        .forEach(it=>{
          const li=document.createElement('li');
          li.textContent=`${it.label}: ${it.value}`;
          lst.appendChild(li);
        });

      Object.keys(allSessions).forEach(g => allSessions[g] = []);
      (profileData.statsByGame || []).forEach(g => {
      const gidCanon = canonId(g.gameId);
      if (!allSessions[gidCanon]) return;
      const arr = (g.sessionHistory || []).slice().sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
      arr.forEach(s => {
        const dt = new Date(s.startTime);
        // если пришло из "HardButterflyGameScene", проставим difficulty='hard'
        const difficultyRaw = (g.gameId === 'HardButterflyGameScene') ? 'hard' : (s.difficulty ?? '');
      const difficulty = String(difficultyRaw).toLowerCase();

      // --- TTF: берём корректное действие, иначе первый выбор ---
      const ttfSel  = Number(s.timeToFirstSelection ?? 0);
      const ttfCorr = Number(s.timeToFirstCorrectAction ?? 0);
      const ttf     = ttfCorr > 0 ? ttfCorr : (ttfSel > 0 ? ttfSel : 0);

      // --- Нормализация метрик для Бабочек (сложный): 
      // если caught/errors не заполнены, подставляем correctActions/incorrectActions ---
      let caught = Number(s.caught ?? 0);
      let errors = Number(s.errors ?? 0);
      if (difficulty === 'hard') {
        if (caught === 0 && (s.correctActions ?? 0) > 0)   caught = Number(s.correctActions);
        if (errors === 0 && (s.incorrectActions ?? 0) > 0) errors = Number(s.incorrectActions);
      }

      allSessions[gidCanon].push({
        dt: new Date(s.startTime),
        duration: Number(s.durationInSeconds || 0),
        correct: Number(s.correctActions || 0),
        incorrect: Number(s.incorrectActions || 0),
        ttf,
        difficulty,
        missed: Number(s.missed || 0),
        caught,
        errors,
        correctPairs: Number(s.correctPairs || 0),
        score: Number(s.score || 0)
      });

        });
      });

      const maxCount=Math.max(...Object.values(allSessions).map(a=>a.length),1);
      filter.indexRange=[1,maxCount];
      let minD=null,maxD=null;
      Object.values(allSessions).forEach(a=>a.forEach(s=>{
        if(!minD||s.dt<minD)minD=s.dt;
        if(!maxD||s.dt>maxD)maxD=s.dt;
      }));
      filter.dateRange=[minD,maxD];

      const rs=document.getElementById('range-start');
      const re=document.getElementById('range-end');
      rs.min=1; re.min=1; rs.max=maxCount; re.max=maxCount; re.value=maxCount;
      const rv=document.getElementById('range-values');
      const upd=()=>{
        rv.textContent=`Выбрано ${rs.value}-${re.value} из ${maxCount}`;
        filter.indexRange=[+rs.value,+re.value];
        applyFiltersAndRender();
      };
      rs.onchange=upd; re.onchange=upd; upd();

      const sI=document.getElementById('start-date');
      const eI=document.getElementById('end-date');
      const toVal=d=>!d?'':`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}T${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      sI.value=toVal(minD); eI.value=toVal(maxD);
      sI.onchange=()=>{
        const d=new Date(sI.value);
        if(!isNaN(d)) {
          filter.dateRange[0]=d;
          applyFiltersAndRender();
        }
      };
      eI.onchange=()=>{
        const d=new Date(eI.value);
        if(!isNaN(d)) {
          filter.dateRange[1]=d;
          applyFiltersAndRender();
        }
      };
      document.getElementById('toggle-ttf').onchange=()=>applyFiltersAndRender();

      document.getElementById('export-csv').onclick=exportCSV;
      
      document.querySelectorAll('.difficulty-filter input').forEach(r => {
        r.onchange = () => applyFiltersAndRender();
      });
      document.querySelectorAll('.chart-controls button').forEach(b=>{
        if(b.dataset.resetId){
          b.onclick=()=>{
            const ch=charts[b.dataset.resetId];
            if(ch&&ch.resetZoom) ch.resetZoom();
          };
        }
        if(b.dataset.downloadId){
          b.addEventListener('click',()=>{
            const ch=charts[b.dataset.downloadId];
            if(!ch) return;
            const a=document.createElement('a');
            a.href=ch.toBase64Image();
            a.download=`${b.dataset.downloadId}-${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
            a.click();
          });
        }
      });

      applyFiltersAndRender();
    }

    function getFilteredSessions() {
      const res = {};
      const [iS, iE] = filter.indexRange.map(v => Math.round(v));
      const [dS, dE] = filter.dateRange;
      Object.keys(allSessions).forEach(g => {
        res[g] = allSessions[g].filter((s, idx) => {
          const i = idx + 1;
          const okI = i >= iS && i <= iE;
          const okD = (!dS || s.dt >= dS) && (!dE || s.dt <= dE);
          return okI && okD;
        });
      });

      // Объединяем сессии бабочек
      if (res.ButterflyGameScene && res.HardButterflyGameScene) {
        res.ButterflyGameScene = res.ButterflyGameScene.concat(res.HardButterflyGameScene);
        res.ButterflyGameScene.sort((a, b) => a.dt - b.dt);
        delete res.HardButterflyGameScene;
      }
      return res;
    }

    function computeTotals(f) {
    const t = { GameScene:0, Fish:0, ButterflyGameScene:0, Snowflakes:0, MemoryMatchScene:0, FrutGame:0 };
    CANON.forEach(g => (f[g]||[]).forEach(s => t[g] += s.duration));
    return t;
 }

    function renderSummary(totals){
      const list=document.getElementById('total-list');
      list.innerHTML='';
      const entries=Object.entries(totals).filter(([,v])=>v>0).sort((a,b)=>b[1]-a[1]);
      entries.forEach(([gid,time])=>{
        const li=document.createElement('li');
        const left=document.createElement('span');
        const m=document.createElement('span');
        m.className='marker';
        m.style.background=COLOR[gid];
        left.appendChild(m);
        const lb=document.createElement('span');
        lb.textContent=NAME[gid];
        left.appendChild(lb);
        li.appendChild(left);
        const right=document.createElement('span');
        right.textContent=formatDuration(time);
        li.appendChild(right);
        list.appendChild(li);
      });

      const data=entries.map(([gid,v])=>v);
      const labels=entries.map(([gid])=>NAME[gid]);
      const colors=entries.map(([gid])=>COLOR[gid]);
      const sum=data.reduce((a,v)=>a+v,0);
      if(charts.pieChart) charts.pieChart.destroy();
      charts.pieChart=new Chart(document.getElementById('pieChart').getContext('2d'),{
        type:'doughnut',
        data:{labels,datasets:[{data,backgroundColor:colors,borderWidth:0}]},
        options:{
          responsive:true,
          maintainAspectRatio:false,
          plugins:{
            legend:{display:false},
            tooltip:{
              callbacks:{
                label:c=>`${c.label}: ${formatDuration(c.parsed)} (${sum? (c.parsed/sum*100).toFixed(1):0}%)`
              }
            }
          },
          cutout:'60%'
        },
        plugins:[pieLabelPlugin]
      });

      const lg=document.getElementById('pie-legend');
      lg.innerHTML='';
      entries.forEach(([gid])=>{
        const d=document.createElement('div');
        d.className='legend-item';
        const box=document.createElement('span');
        box.className='legend-color';
        box.style.background=COLOR[gid];
        const tx=document.createElement('span');
        tx.textContent=NAME[gid];
        d.appendChild(box);
        d.appendChild(tx);
        lg.appendChild(d);
      });
    }

    function legendRect(){
      return {
        labels: {
          usePointStyle: false,
          generateLabels(chart) {
            const ds = chart.data.datasets || [];
            return ds.map((d,i)=>({
              text: d.label,
              fillStyle: d.borderColor || d.backgroundColor,
              strokeStyle: d.borderColor || d.backgroundColor,
              hidden: !chart.isDatasetVisible(i),
              datasetIndex: i
            }));
          }
        }
      };
    }

    const zoomOpts = {
      zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'x'},
      pan:{enabled:true,mode:'x'}
    };

    function axis(yMax){
      const step=Math.max(1,Math.ceil(yMax/4));
      let max=step*4;
      if(yMax>max) max=step*5;
      return {step,max};
    }

    function oneLineLabel(dt){
      const Y=dt.getFullYear();
      const M=String(dt.getMonth()+1).padStart(2,'0');
      const D=String(dt.getDate()).padStart(2,'0');
      const h=String(dt.getHours()).padStart(2,'0');
      const m=String(dt.getMinutes()).padStart(2,'0');
      const s=String(dt.getSeconds()).padStart(2,'0');
      return `${Y}-${M}-${D} ${h}:${m}:${s}`;
    }
    const showTTF = document.getElementById('chkTTF')?.checked === true;

    function renderCharts(f){
      // читаем оба возможных id чекбокса
const ttfChecked =
  (document.getElementById('toggle-ttf')?.checked ?? false) ||
  (document.getElementById('chkTTF')?.checked ?? false);

      // Цветочный сад
      (()=>{
        const gid='GameScene';
        const d=f[gid];
        const c=document.getElementById('gameChart');
        if(charts.gameChart) charts.gameChart.destroy();
        if(!d||!d.length){
          c.getContext('2d').clearRect(0,0,c.width,c.height);
          return;
        }
        // Чекбокс TTF: поддерживаем оба id (toggle-ttf и chkTTF)
       const ttfChecked =
          (document.getElementById('toggle-ttf')?.checked ?? document.getElementById('chkTTF')?.checked) === true;
        const showTTF = ttfChecked && d.some(s => (s.ttf ?? 0) > 0);
        let yMax = Math.max(...d.map(s => s.duration || 0));
        if (showTTF) yMax = Math.max(yMax, ...d.map(s => s.ttf || 0));
        const {step,max}=axis(yMax);
        const labels=d.map(s=>oneLineLabel(s.dt));

        const ds=[{
          label:'Длительность, с',
          data:d.map(s=>s.duration),
          borderColor:COLOR[gid],
          backgroundColor:COLOR[gid],
          tension:.2,
          fill:false,
          pointRadius:4,
          pointHoverRadius:5,
          yAxisID:'y'  
        }];
        if(showTTF){
          ds.push({
            label:'Время до первого выбора, с',
            data:d.map(s=>s.ttf ?? null),
            borderColor:COLOR.TTF,
            backgroundColor:COLOR.TTF,
            borderDash:[6,4],
            tension:.2,
            fill:false,
            pointRadius:4,
            pointStyle:'rectRot',
            pointHoverRadius:5,
            yAxisID:'yTime'        // правая ось для TTF
          });
        }

        charts.gameChart=new Chart(c.getContext('2d'),{
          type:'line',
          data:{labels,datasets:ds},
          options:{
            responsive:true,
            maintainAspectRatio:false,
            scales:{
              x:{
                type:'category',
                ticks:{
                  autoSkip:false,
                  maxRotation:45,
                  minRotation:45,
                  color:'#000',
                  callback:function(v){ return this.getLabelForValue(v); }
                },
                grid:{color:'#E0E0E0'},
                border:{color:'#AAA'}
              },
              y:{
                position:'left',
                suggestedMin:0,
                suggestedMax:max,
                ticks:{stepSize:step,color:'#000'},
                grid:{color:'#E0E0E0'},
                border:{color:'#AAA'}
              },
              yTime:{
                position:'right',
                suggestedMin:0,
                suggestedMax:max,
                ticks:{stepSize:step,color:'#000'},
                grid:{drawOnChartArea:false},
                border:{color:'#AAA'}
              }
            },
            plugins:{legend:{position:'top',...legendRect()},
              tooltip:{callbacks:{title:c=>{const i=c[0].dataIndex; const dt=d[i].dt; return `#${i+1} — ${dt.toISOString().replace('T',' ').slice(0,19)}`},
                                   label:c=>`${c.dataset.label}: ${c.parsed.y.toFixed(2)}`}},
              zoom: zoomOpts
            }}
        });
      })();

      // Аквариум
      (()=>{
        const gid='Fish';
        let d=f[gid];
        const c=document.getElementById('fishChart');
        if(charts.fishChart) charts.fishChart.destroy();
        
        const diff = document.querySelector('input[name="fishDiff"]:checked').value;
        if (d) {
          if (diff !== 'all') {
            d = d.filter(s => s.difficulty === diff);
          }
        }

        if(!d||!d.length){
          c.getContext('2d').clearRect(0,0,c.width,c.height);
          document.getElementById('chart-container-fish').style.display = 'none';
          return;
        }
        document.getElementById('chart-container-fish').style.display = 'block';

        const labels=d.map(s=>oneLineLabel(s.dt));
        const showTTF = ttfChecked && d.some(s => (s.ttf ?? 0) > 0);


        const yMaxCounts=Math.max(1,...d.map(s=>Math.max(s.correct,s.incorrect, s.missed || 0)));
        const stepCounts=Math.max(1,Math.ceil(yMaxCounts/4));
        const suggestedMaxCounts=Math.max(yMaxCounts,stepCounts*4);

        const yMaxTime=showTTF?Math.max(...d.map(s=>s.ttf||0),1):1;
        const stepTime=Math.max(1,Math.ceil(yMaxTime/4));
        const suggestedMaxTime=Math.max(yMaxTime,stepTime*4);

        const cat=0.80;
        const bar=1.00;

        const datasets=[
          {
            label:'Правильные',
            data:d.map(s=>s.correct),
            backgroundColor:COLOR[gid],
            borderColor:COLOR[gid],
            borderWidth:0,
            yAxisID:'yCounts',
            order:2,
            barPercentage:bar,
            categoryPercentage:cat
          },
          {
            label:'Ошибки',
            data:d.map(s=>s.incorrect),
            backgroundColor:COLOR.ERR,
            borderColor:COLOR.ERR,
            borderWidth:0,
            yAxisID:'yCounts',
            order:2,
            barPercentage:bar,
            categoryPercentage:cat
          }
        ];

        if (d.some(s => s.missed > 0)) {
          datasets.push({
            label: 'Пропущенные',
            data: d.map(s => s.missed),
            backgroundColor: '#FFA726',
            yAxisID: 'yCounts',
            order: 2,
            barPercentage: bar,
            categoryPercentage: cat
          });
        }

        if(showTTF){
          datasets.push({
            type:'line',
            label:'Время до первого выбора, с',
            data:d.map(s=>s.ttf||null),
            borderColor:COLOR.TTF,
            backgroundColor:COLOR.TTF,
            pointRadius:3,
            tension:0.2,
            yAxisID:'yTime',
            order:1
          });
        }

        charts.fishChart=new Chart(c.getContext('2d'),{
          type:'bar',
          data:{labels,datasets},
          options:{
            responsive:true,
            maintainAspectRatio:false,
            scales:{
              x:{
                type:'category',
                ticks:{
                  autoSkip:false,
                  maxRotation:45,
                  minRotation:45,
                  color:'#000',
                  callback:function(v){ return this.getLabelForValue(v); }
                },
                grid:{color:'#E0E0E0'},
                border:{color:'#AAA'}
              },
              yCounts:{
                type:'linear',
                position:'left',
                beginAtZero:true,
                suggestedMax:suggestedMaxCounts,
                ticks:{stepSize:stepCounts,color:'#000'},
                grid:{color:'#E0E0E0'},
                border:{color:'#AAA'}
              },
              yTime:{
                type:'linear',
                position:'right',
                display:showTTF,
                beginAtZero:true,
                suggestedMax:suggestedMaxTime,
                ticks:{stepSize:stepTime,color:'#000'},
                grid:{drawOnChartArea:false},
                border:{color:'#AAA'}
              }
            },
            plugins:{legend:{position:'top',...legendRect()},
              tooltip:{callbacks:{title:c=>{const i=c[0].dataIndex; const dt=d[i].dt; return `#${i+1} — ${dt.toISOString().replace('T',' ').slice(0,19)}`},
                                   label:c=> c.dataset.yAxisID==='yTime'
                                     ? `${c.dataset.label}: ${c.parsed.y.toFixed(2)}`
                                     : `${c.dataset.label}: ${c.parsed.y}`}},
              zoom: zoomOpts
            }
          }
        });
      })();

      // Бабочки
      (()=>{
        const gid='ButterflyGameScene';
        let d=f[gid];
        const c=document.getElementById('butterflyChart');
        if(charts.butterflyChart) charts.butterflyChart.destroy();

        const diff = document.querySelector('input[name="butterflyDiff"]:checked').value;
        if (d) {
          if (diff !== 'all') d = d.filter(s => s.difficulty === diff);
        }

        if(!d||!d.length){
          c.getContext('2d').clearRect(0,0,c.width,c.height);
          document.getElementById('chart-container-butterfly').style.display = 'none';
          return;
        }
        document.getElementById('chart-container-butterfly').style.display = 'block';

        const labels=d.map(s=>oneLineLabel(s.dt));

        // ✅ TTF чекбокс: пробуем оба id, чтобы везде сработало
        const ttfChk =
          (document.getElementById('toggle-ttf') && document.getElementById('toggle-ttf').checked) ||
          (document.getElementById('chkTTF') && document.getElementById('chkTTF').checked);
        const showTTF = ttfChecked && d.some(s => (s.ttf ?? 0) > 0);


        const datasets = [];
        const yAxes = {};
        const bar = 1.0, cat = 0.8; // как в Аквариуме

        // --- Ось времени (правая) ---
        const yMaxTime = Math.max(1, ...d.map(s => s.duration), ...(showTTF ? d.map(s => s.ttf || 0) : []));
        const timeAxis = axis(yMaxTime);
        yAxes.yTime = {
          type: 'linear',
          position: 'right',
          beginAtZero: true,
          suggestedMax: timeAxis.max,
          ticks: { stepSize: timeAxis.step, color: '#000' },
          grid: { drawOnChartArea: false },
          border: { color: '#AAA' }
        };

        // Длительность
        datasets.push({
          type: 'line',
          label: 'Длительность, с',
          data: d.map(s => s.duration),
          borderColor: COLOR.ButterflyGameScene,
          backgroundColor: COLOR.ButterflyGameScene,
          pointRadius: 3,
          tension: 0.2,
          yAxisID: 'yTime',
          order: 1
        });

        // Время до первого выбора (TTF) — пунктир
        if (showTTF) {
          datasets.push({
            type: 'line',
            label: 'Время до первого выбора, с',
            data: d.map(s => s.ttf || null),
            borderColor: COLOR.TTF,
            backgroundColor: COLOR.TTF,
            borderDash: [6,4],
            pointRadius: 3,
            tension: 0.2,
            yAxisID: 'yTime',
            order: 0
          });
        }

        // --- Ось количества (левая) ---
        const easyData = d.filter(s => s.difficulty === 'easy');
        const hardData = d.filter(s => s.difficulty === 'hard');

        let yMaxCounts = 1;
        if (easyData.length) yMaxCounts = Math.max(yMaxCounts, ...easyData.map(s => s.correct||0));
        if (hardData.length) yMaxCounts = Math.max(
          yMaxCounts,
          ...hardData.map(s => s.caught||0),
          ...hardData.map(s => s.errors||0)
        );

        const countAxis = axis(yMaxCounts);
        yAxes.yCounts = {
          type: 'linear',
          position: 'left',
          beginAtZero: true,
          suggestedMax: countAxis.max,
          ticks: { stepSize: countAxis.step, color: '#000' },
          grid: { color: '#E0E0E0' },
          border: { color: '#AAA' }
        };

        // --- Датасеты по сложности (бар-сеты — как в Аквариуме) ---

        // Лёгкий: правильные
        if (diff === 'easy' || diff === 'all') {
          const arr = d.map(s => s.difficulty === 'easy' ? (s.correct||0) : null);
          if (arr.some(v=>v)) {
            datasets.push({
              label: 'Правильные (лёгкий)',
              data: arr,
              backgroundColor: "#9C27B0", // фиолетовый вспомогательный
              yAxisID: 'yCounts',
              order: 2,
              barPercentage: bar,
              categoryPercentage: cat
            });
          }
        }

        // Сложный: поймано
        if (diff === 'hard' || diff === 'all') {
          const arrCaught = d.map(s => s.difficulty === 'hard' ? (s.caught||0) : null);
          if (arrCaught.some(v=>v)) {
            datasets.push({
              label: 'Поймано (сложный)',
              data: arrCaught,
              backgroundColor: '#26A69A',
              yAxisID: 'yCounts',
              order: 2,
              barPercentage: bar,
              categoryPercentage: cat
            });
          }
          // Сложный: ошибки
          const arrErr = d.map(s => s.difficulty === 'hard' ? (s.errors||0) : null);
          if (arrErr.some(v=>v)) {
            datasets.push({
              label: 'Ошибки (сложный)',
              data: arrErr,
              backgroundColor: COLOR.ERR,
              yAxisID: 'yCounts',
              order: 2,
              barPercentage: bar,
              categoryPercentage: cat
            });
          }
        }

        charts.butterflyChart=new Chart(c.getContext('2d'), {
          type: 'bar',
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: 'category',
                ticks: { autoSkip: false, maxRotation: 45, minRotation: 45, color: '#000' },
                grid: { color: '#E0E0E0' },
                border: { color: '#AAA' }
              },
              ...yAxes
            },
            plugins: {
              legend: { position: 'top', ...legendRect() },
              tooltip: {
                callbacks: {
                  title: c => { const i = c[0].dataIndex; const dt = d[i].dt; return `#${i + 1} — ${dt.toISOString().replace('T', ' ').slice(0, 19)}` }
                }
              },
              zoom: zoomOpts
            }
          }
        });
      })();

      // Снежинки
      (()=>{
        const gid='Snowflakes';
        const d=f[gid];
        const c=document.getElementById('snowflakesChart');
        if(charts.snowflakesChart) charts.snowflakesChart.destroy();
        if(!d||!d.length){
          c.getContext('2d').clearRect(0,0,c.width,c.height);
          document.getElementById('chart-container-snowflakes').style.display = 'none';
          return;
        }
        document.getElementById('chart-container-snowflakes').style.display = 'block';
        
        const showTTF = ttfChecked && d.some(s => (s.ttf ?? 0) > 0);

        let yMax=Math.max(...d.map(s=>s.duration));
        if(showTTF) yMax=Math.max(yMax,...d.map(s=>s.ttf));
        const {step,max}=axis(yMax);
        const labels=d.map(s=>oneLineLabel(s.dt));

        const ds=[{
          label:'Длительность, с',
          data:d.map(s=>s.duration),
          borderColor:COLOR[gid],
          backgroundColor:COLOR[gid],
          tension:.2,
          fill:false,
          pointRadius:4,
          pointHoverRadius:5
        }];
        if(showTTF){
          ds.push({
            label:'Время до первого выбора, с',
            data:d.map(s=>s.ttf),
            borderColor:COLOR.TTF,
            backgroundColor:COLOR.TTF,
            borderDash:[4,2],
            tension:.2,
            fill:false,
            pointRadius:4,
            pointStyle:'rectRot',
            pointHoverRadius:5
          });
        }

        charts.snowflakesChart=new Chart(c.getContext('2d'),{
          type:'line',
          data:{labels,datasets:ds},
          options:{
            responsive:true,
            maintainAspectRatio:false,
            scales:{
              x:{
                type:'category',
                ticks:{ autoSkip:false, maxRotation:45, minRotation:45, color:'#000' },
                grid:{color:'#E0E0E0'},
                border:{color:'#AAA'}
              },
              y:{suggestedMin:0,suggestedMax:max,ticks:{stepSize:step,color:'#000'},grid:{color:'#E0E0E0'},border:{color:'#AAA'}}
            },
            plugins:{
              legend:{position:'top',...legendRect()},
              tooltip:{callbacks:{title:c=>{const i=c[0].dataIndex; const dt=d[i].dt; return `#${i+1} — ${dt.toISOString().replace('T',' ').slice(0,19)}`},
                                   label:c=>`${c.dataset.label}: ${c.parsed.y.toFixed(2)}`}},
              zoom: zoomOpts
            }}
        });
      })();

      // Карточки
      (()=>{
        const gid='MemoryMatchScene';
        let d=f[gid];
        const c=document.getElementById('memoryChart');
        if(charts.memoryChart) charts.memoryChart.destroy();

        const diff = document.querySelector('input[name="memoryDiff"]:checked').value;
        if(d) {
            if (diff !== 'all') {
                d = d.filter(s => String(s.difficulty) === String(diff));
            }
        }
        
        if(!d||!d.length){
          c.getContext('2d').clearRect(0,0,c.width,c.height);
          document.getElementById('chart-container-memory').style.display = 'none';
          return;
        }
        document.getElementById('chart-container-memory').style.display = 'block';
        const cat=0.80;
        const bar=1.00;
        const labels=d.map(s=>oneLineLabel(s.dt));
        const showTTF = ttfChecked && d.some(s => (s.ttf ?? 0) > 0);


        const datasets = [];
        const yAxes = {};

        const yMaxTime = Math.max(1, ...d.map(s => s.duration), ...(showTTF ? d.map(s => s.ttf || 0) : []));
        const timeAxis = axis(yMaxTime);
        yAxes.yTime = {
            type: 'linear',
            position: 'right',
            beginAtZero: true,
            suggestedMax: timeAxis.max,
            ticks: { stepSize: timeAxis.step, color: '#000' },
            grid: { drawOnChartArea: false },
            border: { color: '#AAA' }
        };
        datasets.push({
            type: 'line',
            label: 'Длительность, с',
            data: d.map(s => s.duration),
            borderColor: COLOR[gid],
            backgroundColor: COLOR[gid],
            pointRadius: 3,
            tension: 0.2,
            yAxisID: 'yTime',
            order: 1
        });
        if (showTTF) {
            datasets.push({
                type: 'line',
                label: 'Время до первого выбора, с',
                data: d.map(s => s.ttf || null),
                borderColor: COLOR.TTF,
                backgroundColor: COLOR.TTF,
                pointRadius: 3,
                tension: 0.2,
                yAxisID: 'yTime',
                order: 0
            });
        }

        const yMaxCounts = Math.max(1, ...d.map(s => Math.max(s.correctPairs || 0, s.errors || 0)));
        const countAxis = axis(yMaxCounts);
        yAxes.yCounts = {
            type: 'linear',
            position: 'left',
            beginAtZero: true,
            suggestedMax: countAxis.max,
            ticks: { stepSize: countAxis.step, color: '#000' },
            grid: { color: '#E0E0E0' },
            border: { color: '#AAA' }
        };
        datasets.push({
            label: 'Правильные пары',
            data: d.map(s => s.correctPairs),
            backgroundColor: '#FFA726',
            yAxisID: 'yCounts',
            order: 2,
            barPercentage: bar,
            categoryPercentage: cat
        });
        datasets.push({
            label: 'Ошибки',
            data: d.map(s => s.errors),
            backgroundColor: COLOR.ERR,
            yAxisID: 'yCounts',
            order: 2,
            barPercentage: bar,
            categoryPercentage: cat
        });

        charts.memoryChart=new Chart(c.getContext('2d'), {
            type: 'bar',
            data: { labels, datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'category',
                        ticks: { autoSkip: false, maxRotation: 45, minRotation: 45, color: '#000' },
                        grid: { color: '#E0E0E0' },
                        border: { color: '#AAA' }
                    },
                    ...yAxes
                },
                plugins: {
                    legend: { position: 'top', ...legendRect() },
                    tooltip: { callbacks: { title: c => { const i = c[0].dataIndex; const dt = d[i].dt; return `#${i + 1} — ${dt.toISOString().replace('T', ' ').slice(0, 19)}` } } },
                    zoom: zoomOpts
                }
            }
        });
      })();

      // Фруктовая битва
      (()=>{
        const gid='FrutGame';
        const d=f[gid];
        const c=document.getElementById('fruitChart');
        if(charts.fruitChart) charts.fruitChart.destroy();
        if(!d||!d.length){
          c.getContext('2d').clearRect(0,0,c.width,c.height);
          document.getElementById('chart-container-fruit').style.display = 'none';
          return;
        }
        document.getElementById('chart-container-fruit').style.display = 'block';

        const labels=d.map(s=>oneLineLabel(s.dt));
        const showTTF = ttfChecked && d.some(s => (s.ttf ?? 0) > 0);


        const datasets = [];
        const yAxes = {};

        const yMaxTime = showTTF ? Math.max(1, ...d.map(s => s.ttf || 0)) : 1;
        const timeAxis = axis(yMaxTime);
        yAxes.yTime = {
            type: 'linear',
            position: 'right',
            display: showTTF,
            beginAtZero: true,
            suggestedMax: timeAxis.max,
            ticks: { stepSize: timeAxis.step, color: '#000' },
            grid: { drawOnChartArea: false },
            border: { color: '#AAA' }
        };

        if (showTTF) {
            datasets.push({
                type: 'line',
                label: 'Время до первого выбора, с',
                data: d.map(s => s.ttf || null),
                borderColor: COLOR.TTF,
                backgroundColor: COLOR.TTF,
                pointRadius: 3,
                tension: 0.2,
                yAxisID: 'yTime',
                order: 0
            });
        }
        
        const yMaxScore = Math.max(1, ...d.map(s => s.score || 0));
        const scoreAxis = axis(yMaxScore);
        yAxes.yScore = {
            type: 'linear',
            position: 'left',
            beginAtZero: true,
            suggestedMax: scoreAxis.max,
            ticks: { stepSize: scoreAxis.step, color: '#000' },
            grid: { color: '#E0E0E0' },
            border: { color: '#AAA' }
        };
        datasets.push({
            label: 'Очки',
            data: d.map(s => s.score),
            backgroundColor: COLOR[gid],
            yAxisID: 'yScore',
            order: 1
        });

        charts.fruitChart=new Chart(c.getContext('2d'), {
            type: 'bar',
            data: { labels, datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'category',
                        ticks: { autoSkip: false, maxRotation: 45, minRotation: 45, color: '#000' },
                        grid: { color: '#E0E0E0' },
                        border: { color: '#AAA' }
                    },
                    ...yAxes
                },
                plugins: {
                    legend: { position: 'top', ...legendRect() },
                    tooltip: { callbacks: { title: c => { const i = c[0].dataIndex; const dt = d[i].dt; return `#${i + 1} — ${dt.toISOString().replace('T', ' ').slice(0, 19)}` } } },
                    zoom: zoomOpts
                }
            }
        });
      })();
    }

    function applyFiltersAndRender(){
      const f = getFilteredSessions();
      const totals = computeTotals(f);
      renderSummary(totals);
      renderCharts(f);
    }

    function exportCSV(){
      const f = getFilteredSessions();
      let csv = 'Игра,Уровень,Дата и время,Длительность (сек),Время до первого выбора (сек),Правильные,Ошибки,Пропущенные,Пойманные,Пары,Очки\n';
      
      const gids = Object.keys(f);

      gids.forEach(gid => {
        const sessions = f[gid] || [];
        sessions.forEach(s => {
          const dateStr = s.dt.toISOString().replace('T', ' ').slice(0, 19);
          const row = [
            NAME[gid],
            s.difficulty || '',
            dateStr,
            s.duration || 0,
            s.ttf || 0,
            s.correct || '',
            s.errors || s.incorrect || '',
            s.missed || '',
            s.caught || '',
            s.correctPairs || '',
            s.score || ''
          ];
          csv += row.join(',') + '\n';
        });
      });
      
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `game-statistics-${new Date().toISOString().slice(0,10)}.csv`;
      link.click();
    }

    // Запуск приложения
    document.addEventListener('DOMContentLoaded', start);
  })();
  </script>
</body>
</html>
